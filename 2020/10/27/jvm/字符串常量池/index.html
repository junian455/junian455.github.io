<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>字符串常量池 | HJ 的学习录</title><meta name="keywords" content="内存分配,intern"><meta name="author" content="阿健君"><meta name="copyright" content="阿健君"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="字符串常量池String 的基本特性String：字符串，使用一对 “ “ 引起来表示。JAVA12String s1 = “hello” ;               // 字面量的定义方式String s2 =  new String(“hello”);   // new 对象的方式String 被声明为 final 的，不可被继承。String 实现了 Serializable 接口：表示">
<meta property="og:type" content="article">
<meta property="og:title" content="字符串常量池">
<meta property="og:url" content="http://example.com/2020/10/27/jvm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/index.html">
<meta property="og:site_name" content="HJ 的学习录">
<meta property="og:description" content="字符串常量池String 的基本特性String：字符串，使用一对 “ “ 引起来表示。JAVA12String s1 = “hello” ;               // 字面量的定义方式String s2 =  new String(“hello”);   // new 对象的方式String 被声明为 final 的，不可被继承。String 实现了 Serializable 接口：表示">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/StringTable.png">
<meta property="article:published_time" content="2020-10-27T02:12:21.000Z">
<meta property="article:modified_time" content="2020-10-27T03:12:21.000Z">
<meta property="article:author" content="阿健君">
<meta property="article:tag" content="内存分配">
<meta property="article:tag" content="intern">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/StringTable.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/10/27/jvm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '字符串常量池',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2020-10-27 11:12:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/scollbar.css"><link rel="stylesheet" href="/css/bottomsetting.css"><link rel="stylesheet" href="/css/card_categor_hide.css"><link rel="stylesheet" href="/css/article_bak_transparent.css"><link rel="stylesheet" href="/css/index_tag.css"><link rel="stylesheet" href="/css/index_tag2.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/index_tag3.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-th-large"></i><span> 百宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-user-shield"></i><span> 评论管理</span></a></li><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-cloud"></i><span> 我的云盘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-photo-video"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-child"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fa-fw fas fa-user-friends"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa-fw fas fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/junian455/pic@master/img/top_img.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HJ 的学习录</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-th-large"></i><span> 百宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-user-shield"></i><span> 评论管理</span></a></li><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-cloud"></i><span> 我的云盘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-photo-video"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-child"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fa-fw fas fa-user-friends"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa-fw fas fa-comments"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">字符串常量池</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-27T02:12:21.000Z" title="发表于 2020-10-27 10:12:21">2020-10-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-27T03:12:21.000Z" title="更新于 2020-10-27 11:12:21">2020-10-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="字符串常量池"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://cdn.jsdelivr.net/gh/junian455/pic@master/img/top_img.png');"></div><article class="post-content" id="article-container"><h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><p>String 的基本特性<br>String：字符串，使用一对 “ “ 引起来表示。<br>JAVA<br>1<br>2<br>String s1 = “hello” ;               // 字面量的定义方式<br>String s2 =  new String(“hello”);   // new 对象的方式<br>String 被声明为 final 的，不可被继承。<br>String 实现了 Serializable 接口：表示字符串是支持序列化的；实现了 Comparable 接口：表示 String 可以比较大小。<br>String 在 jdk8 及以前内部定义了 final char value [] 用于存储字符串数据，jdk9 时改为 byte [] 。<br>为什么 JDK9 改变了 String 的结构？</p>
<p>官方文档：<a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/254">http://openjdk.java.net/jeps/254</a></p>
<p>为什么改为 byte [] 存储？</p>
<p>String 类的当前实现将字符存储在 char 数组中，每个字符使用两个字节 (16 位)。从许多不同的应用程序收集的数据表明，字符串是堆的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1），这些字符只需要一个字节的存储空间，因此这些字符串对象的内部 char 数组中有一半的空间将不会使用，产生了大量浪费；<br>之前 String 类使用 UTF-16 的 char [] 数组存储，现在改为 byte [] 数组外加一个编码标识存储。该编码表示如果你的字符是 ISO-8859-1 或者 Latin-1 ，那么只需要一个字节存储。如果你是其它字符集，比如 UTF-8 ，仍然用两个字节存储，这样 String 再也不用 char [] 来存储了，改成了 byte [] 加上编码标记，节约了一些空间，同时基于 String 的数据结构，例如 StringBuffe r 和 StringBuilder 也同样做了修改。<br>JAVA<br>1<br>2<br>3<br>4<br>// 之前<br>private final char value[];<br>// 之后<br>private final byte[] value<br>基本特性</p>
<p>String：代表不可变的字符序列，简称：不可变性。</p>
<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
<li>当调用 String 的 replace() 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。<br>通过字面量的方式（区别于 new ）给一个字符串赋值，此时的字符串值声明在字符串常量池中。<br>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
</ul>
<p>示例代码：重新赋值</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>@Test<br>   public void test1() {<br>       String s1 = “abc”;//字面量定义的方式，”abc”存储在字符串常量池中<br>       String s2 = “abc”;<br>       s1 = “hello”;</p>
<pre><code>   System.out.println(s1 == s2);//判断地址：true  --&gt; false

   System.out.println(s1);//
   System.out.println(s2);//abc
</code></pre>
<p>   }<br>输出：</p>
<p>JAVA<br>1<br>2<br>3<br>false<br>hello<br>abc<br>字节码指令：</p>
<p>取字符串 “abc” 时，使用的是同一个符号引用：#2<br>取字符串 “hello” 时，使用的是另一个符号引用：#3<br>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</p>
<p>示例代码：字符串连接</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>@Test<br>   public void test2() {<br>       String s1 = “abc”;<br>       String s2 = “abc”;<br>       s2 += “def”;<br>       System.out.println(s2);//abcdef<br>       System.out.println(s1);//abc<br>   }</p>
<p>当调用 string 的 replace () 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</p>
<p>示例代码：调用 replace（） 方法</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>@Test<br>public void test3() {<br>    String s1 = “abc”;<br>    String s2 = s1.replace(‘a’, ‘m’);<br>    System.out.println(s1);//abc<br>    System.out.println(s2);//mbc<br>}<br>一道笔试题：</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>public class StringExer {<br>    String str = new String(“good”);<br>    char[] ch = {‘t’, ‘e’, ‘s’, ‘t’};</p>
<pre><code>public void change(String str, char ch[]) {
    str = "test ok";
    ch[0] = 'b';
}

public static void main(String[] args) {
    StringExer ex = new StringExer();
    ex.change(ex.str, ex.ch);
    System.out.println(ex.str);//输出：good
    System.out.println(ex.ch);//输出：best
}
</code></pre>
<p>}<br>str 的内容并没有变：“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容。<br>String 的底层结构<br>字符串常量池是不会存储相同内容的字符串的。</p>
<p>String 的 String Pool（字符串常量池）是一个固定大小的 Hashtable ，默认值大小长度是 1009。如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用 String.intern () 方法时性能会大幅下降。<br>使用 -XX:StringTablesize 可设置 StringTable 的长度；<br>在 JDK6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快，而 StringTablesize 设置没有要求；<br>在 JDK7 中，StringTable 的长度默认值是 60013 ，StringTablesize 设置没有要求；<br>在 JDK8 中，StringTable 的长度默认值是 60013，StringTable 可以设置的最小值为 1009。<br>JDK8 下：</p>
<pre><code class="bash">Error: Could not create the Java. Virtual Machine.
Error: A fatal exception has occurred. Program will exit.
StringTable size of 10 is invalid; must be between 1009 and 1305843009213693951
</code></pre>
<blockquote>
<p>测试不同 StringTable 长度下程序的性能，示例代码如下：</p>
</blockquote>
<pre><code class="bash">/**
 * 产生10万个长度不超过10的字符串，包含a-z,A-Z
 */
public class GenerateString {
    public static void main(String[] args) throws IOException {
        FileWriter fw =  new FileWriter("words.txt");

        for (int i = 0; i &lt; 100000; i++) {
            //1 - 10
           int length = (int)(Math.random() * (10 - 1 + 1) + 1);
            fw.write(getString(length) + "\n");
        }

        fw.close();
    }

    public static String getString(int length){
        String str = "";
        for (int i = 0; i &lt; length; i++) {
            //65 - 90, 97-122
            int num = (int)(Math.random() * (90 - 65 + 1) + 65) + (int)(Math.random() * 2) * 32;
            str += (char)num;
        }
        return str;
    }
}
</code></pre>
<pre><code class="bash">public class StringTest2 {
    public static void main(String[] args) {

        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader("words.txt"));
            long start = System.currentTimeMillis();
            String data;
            while((data = br.readLine()) != null){
                data.intern(); //如果字符串常量池中没有对应data的字符串的话，则在常量池中生成
            }

            long end = System.currentTimeMillis();

            System.out.println("花费的时间为：" + (end - start));//1009:143ms  100009:47ms
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(br != null){
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }
    }
}
</code></pre>
<p>-XX:StringTableSize=1009 ：程序耗时 505ms.<br>-XX:StringTableSize=100009 ：程序耗时 116ms.<br>String 的内存分配<br>在 Java 语言中有 8 种基本数据类型和一种比较特殊的类型 String 。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>
<p>常量池就类似一个 Java 系统级别提供的缓存。8 种基本数据类型的常量池都是系统协调的，String 类型的常量池比较特殊。它的主要使用方法有两种：</p>
<p>直接使用双引号声明出来的 String 对象会直接存储在常量池中。比如：String info=”atqq.com” ;<br>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern () 方法。<br>Java 6 及以前，字符串常量池存放在永久代；<br>Java 7 中 将字符串常量池的位置调整到 Java 堆内；<br>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以在进行调优应用时仅需要调整堆大小就可以了；<br>字符串常量池概念原本使用得比较多，但是这个改动使得需要重新考虑在 Java 7 中使用 String.intern ()；<br>Java 8 元空间，字符串常量在堆。<br>StringTable 为什么要调整？</p>
<p>官方文档:<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes</a></p>
<p>永久代的默认空间大小比较小；<br>永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行 Full GC 产生 STW 或者容易产生 OOM：PermGen Space；<br>堆中空间足够大，字符串可被及时回收。<br>在 JDK 7 中，interned 字符串不再在 Java 堆的永久代中分配，而是在 Java 堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主 Java 堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</p>
<p>示例代码：</p>
<pre><code class="bash">/**
 * jdk6中：
 * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m
 *
 * jdk8中：
 * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m
 */
public class StringTest3 {
    public static void main(String[] args) {
        //使用Set保持着常量池引用，避免full gc回收常量池行为
        Set&lt;String&gt; set = new HashSet&lt;String&gt;();
        //在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。
        short i = 0;
        while(true){
            set.add(String.valueOf(i++).intern());
        }
    }
}
</code></pre>
<p>输出结果：字符串真的在堆中（JDK8）</p>
<pre><code class="bash">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
    at java.util.HashMap.resize(HashMap.java:703)
    at java.util.HashMap.putVal(HashMap.java:662)
    at java.util.HashMap.put(HashMap.java:611)
    at java.util.HashSet.add(HashSet.java:219)
    at com.atguigu.java.StringTest3.main(StringTest3.java:22)

Process finished with exit code 1
</code></pre>
<p>String 的基本操作<br>Java 语言规范里要求完全相同的字符串字面量，应该包含同样的 Unicode 字符序列（包含同一份码点序列的常量），并且必须是指向同一个 String 类实例。</p>
<p>示例 1：</p>
<pre><code class="bash">public class StringTest4 {
    public static void main(String[] args) {
        System.out.println();//2293
        System.out.println("1");//2294
        System.out.println("2");
        System.out.println("3");
        System.out.println("4");
        System.out.println("5");
        System.out.println("6");
        System.out.println("7");
        System.out.println("8");
        System.out.println("9");
        System.out.println("10");//2303
        //如下的字符串"1" 到 "10"不会再次加载
        System.out.println("1");//2304
        System.out.println("2");//2304
        System.out.println("3");
        System.out.println("4");
        System.out.println("5");
        System.out.println("6");
        System.out.println("7");
        System.out.println("8");
        System.out.println("9");
        System.out.println("10");//2304
    }
}
</code></pre>
<p>结论：加依次载完字符串”1” 到”10” ，后面的字符串”1” 到 “10” 不会再次加载。</p>
<p>字符串拼接操作</p>
<p>常量与常量的拼接结果在常量池，原理是编译期优化；<br>常量池中不会存在相同内容的变量；<br>拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是 StringBuilder ；<br>如果拼接的结果调用 intern () 方法，根据该字符串是否在常量池中存在，分为：<br>        -      如果存在，则返回字符串在常量池中的地址；</p>
<ul>
<li>如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址。<br>常量与常量的拼接结果在常量池，原理是编译期优化。<br>示例代码：</li>
</ul>
<pre><code class="bash">@Test
    public void test1(){
        String s1 = "a" + "b" + "c";//编译期优化：等同于"abc"
        String s2 = "abc"; //"abc"一定是放在字符串常量池中，将此地址赋给s2
        /*
         * 最终.java编译成.class,再执行.class
         * String s1 = "abc";
         * String s2 = "abc"
         */
        System.out.println(s1 == s2); //true
        System.out.println(s1.equals(s2)); //true
    }
</code></pre>
<blockquote>
<p>从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”。</p>
</blockquote>
<pre><code class="bash">0 ldc #2 &lt;abc&gt;
2 astore_1
3 ldc #2 &lt;abc&gt;
5 astore_2
6 getstatic #3 &lt;java/lang/System.out&gt;
9 aload_1
10 aload_2
11 if_acmpne 18 (+7)
14 iconst_1
15 goto 19 (+4)
18 iconst_0
19 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
22 getstatic #3 &lt;java/lang/System.out&gt;
25 aload_1
26 aload_2
27 invokevirtual #5 &lt;java/lang/String.equals&gt;
30 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
33 return
</code></pre>
<blockquote>
<p>拼接前后，只要其中有一个是变量，结果就在堆中。而调用 intern () 方法，则主动将字符串对象存入字符串常量池中，并将其地址返回。</p>
</blockquote>
<pre><code class="bash">@Test
    public void test2(){
        String s1 = "javaEE";
        String s2 = "hadoop";

        String s3 = "javaEEhadoop";
        String s4 = "javaEE" + "hadoop";//编译期优化
        //如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop
        String s5 = s1 + "hadoop";
        String s6 = "javaEE" + s2;
        String s7 = s1 + s2;

        System.out.println(s3 == s4);//true
        System.out.println(s3 == s5);//false
        System.out.println(s3 == s6);//false
        System.out.println(s3 == s7);//false
        System.out.println(s5 == s6);//false
        System.out.println(s5 == s7);//false
        System.out.println(s6 == s7);//false
        //intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；
        //如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。
        String s8 = s6.intern();
        System.out.println(s3 == s8);//true
    }
</code></pre>
<blockquote>
<p>从字节码角度来看：拼接前后有变量，都会使用到 StringBuilder 类。</p>
</blockquote>
<pre><code class="bash">0 ldc #6 &lt;javaEE&gt;
2 astore_1
3 ldc #7 &lt;hadoop&gt;
5 astore_2
6 ldc #8 &lt;javaEEhadoop&gt;
8 astore_3
9 ldc #8 &lt;javaEEhadoop&gt;
11 astore 4
13 new #9 &lt;java/lang/StringBuilder&gt;
16 dup
17 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;
20 aload_1
21 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;
24 ldc #7 &lt;hadoop&gt;
26 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;
29 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;
32 astore 5
34 new #9 &lt;java/lang/StringBuilder&gt;
37 dup
38 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;
41 ldc #6 &lt;javaEE&gt;
43 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;
46 aload_2
47 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;
50 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;
53 astore 6
55 new #9 &lt;java/lang/StringBuilder&gt;
58 dup
59 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;
62 aload_1
63 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;
66 aload_2
67 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;
70 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;
73 astore 7
75 getstatic #3 &lt;java/lang/System.out&gt;
78 aload_3
79 aload 4
81 if_acmpne 88 (+7)
84 iconst_1
85 goto 89 (+4)
88 iconst_0
89 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
92 getstatic #3 &lt;java/lang/System.out&gt;
95 aload_3
96 aload 5
98 if_acmpne 105 (+7)
101 iconst_1
102 goto 106 (+4)
105 iconst_0
106 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
109 getstatic #3 &lt;java/lang/System.out&gt;
112 aload_3
113 aload 6
115 if_acmpne 122 (+7)
118 iconst_1
119 goto 123 (+4)
122 iconst_0
123 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
126 getstatic #3 &lt;java/lang/System.out&gt;
129 aload_3
130 aload 7
132 if_acmpne 139 (+7)
135 iconst_1
136 goto 140 (+4)
139 iconst_0
140 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
143 getstatic #3 &lt;java/lang/System.out&gt;
146 aload 5
148 aload 6
150 if_acmpne 157 (+7)
153 iconst_1
154 goto 158 (+4)
157 iconst_0
158 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
161 getstatic #3 &lt;java/lang/System.out&gt;
164 aload 5
166 aload 7
168 if_acmpne 175 (+7)
171 iconst_1
172 goto 176 (+4)
175 iconst_0
176 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
179 getstatic #3 &lt;java/lang/System.out&gt;
182 aload 6
184 aload 7
186 if_acmpne 193 (+7)
189 iconst_1
190 goto 194 (+4)
193 iconst_0
194 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
197 aload 6
199 invokevirtual #13 &lt;java/lang/String.intern&gt;
202 astore 8
204 getstatic #3 &lt;java/lang/System.out&gt;
207 aload_3
208 aload 8
210 if_acmpne 217 (+7)
213 iconst_1
214 goto 218 (+4)
217 iconst_0
218 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
221 return
</code></pre>
<p>字符串拼接的底层细节示例说明：</p>
<p>示例 1</p>
<pre><code class="bash">@Test
public void test3(){
    String s1 = "a";
    String s2 = "b";
    String s3 = "ab";
    /*
    如下的 s1 + s2 的执行细节：(变量s是临时定义的）
    ① StringBuilder s = new StringBuilder();
    ② s.append("a")
    ③ s.append("b")
    ④ s.toString()  --&gt; 约等于 new String("ab")，但不等价

    补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer
     */
    String s4 = s1 + s2;//
    System.out.println(s3 == s4);//false
}
</code></pre>
<p>字节码指令如下；</p>
<pre><code class="bash">0 ldc #14 &lt;a&gt;
2 astore_1
3 ldc #15 &lt;b&gt;
5 astore_2
6 ldc #16 &lt;ab&gt;
8 astore_3
9 new #9 &lt;java/lang/StringBuilder&gt;
12 dup
13 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;
16 aload_1
17 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;
20 aload_2
21 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;
24 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;
27 astore 4
29 getstatic #3 &lt;java/lang/System.out&gt;
32 aload_3
33 aload 4
35 if_acmpne 42 (+7)
38 iconst_1
39 goto 43 (+4)
42 iconst_0
43 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
46 return
</code></pre>
<p>示例 2</p>
<pre><code class="bash">/*
    1. 字符串拼接操作不一定使用的是StringBuilder!
       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。
    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。
     */
    @Test
    public void test4(){
        final String s1 = "a";
        final String s2 = "b";
        String s3 = "ab";
        String s4 = s1 + s2;
        System.out.println(s3 == s4);//true
    }
</code></pre>
<p>从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”。</p>
<pre><code class="bash">0 ldc #14 &lt;a&gt;
2 astore_1
3 ldc #15 &lt;b&gt;
5 astore_2
6 ldc #16 &lt;ab&gt;
8 astore_3
9 ldc #16 &lt;ab&gt;
11 astore 4
13 getstatic #3 &lt;java/lang/System.out&gt;
16 aload_3
17 aload 4
19 if_acmpne 26 (+7)
22 iconst_1
23 goto 27 (+4)
26 iconst_0
27 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
30 return
</code></pre>
<p>拼接操作与 append 操作的效率对比：</p>
<pre><code class="bash">
    @Test
    public void test6(){

        long start = System.currentTimeMillis();

//        method1(100000);//4014
        method2(100000);//7

        long end = System.currentTimeMillis();

        System.out.println("花费的时间为：" + (end - start));
    }

    public void method1(int highLevel){
        String src = "";
        for(int i = 0;i &lt; highLevel;i++){
            src = src + "a";//每次循环都会创建一个StringBuilder、String
        }
//        System.out.println(src);

    }

    public void method2(int highLevel){
        //只需要创建一个StringBuilder
        StringBuilder src = new StringBuilder();
        for (int i = 0; i &lt; highLevel; i++) {
            src.append("a");
        }
//        System.out.println(src);
    }
</code></pre>
<p>体会执行效率：通过 StringBuilder 的 append () 的方式添加字符串的效率要远高于使用 String 的字符串拼接方式！<br>原因：<br>StringBuilder 的 append () 的方式：自始至终中只创建过一个 StringBuilder 的对象；<br>使用 String 的字符串拼接方式：创建过多个 StringBuilder 和 String（调的 toString 方法）的对象，内存占用更大；如果进行 GC ，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。<br>改进的空间：<br>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值 highLevel 的情况下，建议使用构造器实例化；<br>StringBuilder s = new StringBuilder(highLevel); //new char[highLevel]<br>可以避免频繁扩容。<br>intern () 的使用<br>intern () 方法的说明：</p>
<p>JAVA<br>1<br>public native String intern();<br>intern 是一个 native 方法，调用的是底层 C 的方法；</p>
<p>字符串常量池最初是空的，由 String 类私有地维护。在调用 intern 方法时，如果池中已经包含了由 equals (object) 方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址（这是源码里的大概翻译）；</p>
<p>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法：intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：</p>
<p>JAVA<br>1<br>String myInfo = new string(“I love you”).intern();<br>如果在任意字符串上调用 String.intern 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是 true ；<br>JAVA<br>1<br>(“a”+”b”+”c”).intern()==”abc”<br>通俗点讲，interned String 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）。<br>new String () 的说明<br>new String (“ab”) 会创建几个对象？</p>
<pre><code class="bash">/**
 * 题目：
 * new String("ab")会创建几个对象？看字节码，就知道是两个。
 *     一个对象是：new关键字在堆空间创建的
 *     另一个对象是：字符串常量池中的对象"ab"。 字节码指令：ldc
 *
 */
public class StringNewTest {
    public static void main(String[] args) {
        String str = new String("ab");
    }
}
</code></pre>
<p>字节码指令：</p>
<pre><code class="bash">
0 new #2 &lt;java/lang/String&gt;
3 dup
4 ldc #3 &lt;ab&gt;
6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;
9 astore_1
10 return
0 new #2 &lt;java/lang/String&gt;：在堆中创建了一个 String 对象
4 ldc #3 ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）
</code></pre>
<h2 id="new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="new String (“a”) + new String (“b”) 会创建几个对象？"></a>new String (“a”) + new String (“b”) 会创建几个对象？</h2><pre><code class="bash">/**
 * 思考：
 * new String("a") + new String("b")呢？
 *  对象1：new StringBuilder()
 *  对象2： new String("a")
 *  对象3： 常量池中的"a"
 *  对象4： new String("b")
 *  对象5： 常量池中的"b"
 *
 *  深入剖析： StringBuilder的toString():
 *      对象6 ：new String("ab")
 *       强调一下，toString()的调用，在字符串常量池中，没有生成"ab"
 *
 */
public class StringNewTest {
    public static void main(String[] args) {

        String str = new String("a") + new String("b");
    }
}
</code></pre>
<p>字节码指令：</p>
<pre><code class="bash">0 new #2 &lt;java/lang/StringBuilder&gt;
3 dup
4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;
7 new #4 &lt;java/lang/String&gt;
10 dup
11 ldc #5 &lt;a&gt;
13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;
16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;
19 new #4 &lt;java/lang/String&gt;
22 dup
23 ldc #8 &lt;b&gt;
25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;
28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;
31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;
34 astore_1
35 return
</code></pre>
<p>字节码指令分析：</p>
<p>0 new #2 &lt;java/lang/StringBuilder&gt; ：拼接字符串会创建一个 StringBuilder 对象；<br>7 new #4 &lt;java/lang/String&gt; ：创建 String 对象，对应于 new String (“a”)；<br>11 ldc #5 ：在字符串常量池中放入 “a”（如果之前字符串常量池中没有 “a” 的话）；<br>19 new #4 &lt;java/lang/String&gt; ：创建 String 对象，对应于 new String (“b”)；<br>23 ldc #8 ：在字符串常量池中放入 “b”（如果之前字符串常量池中没有 “b” 的话）；<br>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt; ：调用 StringBuilder 的 toString () 方法，会生成一个 String 对象。<br>如何保证变量 s 指向的是字符串常量池中的数据呢？</p>
<pre><code class="bash">**
 * 如何保证变量s指向的是字符串常量池中的数据呢？
 * 有两种方式：
 * 方式一： String s = "shkstart";//字面量定义的方式
 * 方式二： 调用intern()
 *         String s = new String("shkstart").intern();
 *         String s = new StringBuilder("shkstart").toString().intern();
 *
 */
</code></pre>
<h2 id="String-对象在不同版本中的内存分析？"><a href="#String-对象在不同版本中的内存分析？" class="headerlink" title="String 对象在不同版本中的内存分析？"></a>String 对象在不同版本中的内存分析？</h2><pre><code class="bash">public class StringIntern {
    public static void main(String[] args) {

        String s = new String("1");//这里在字符串常量池中创建了1
        s.intern();
        String s2 = "1";
        //这里其实是堆中的对象s与字符串常量池中的s2进行判断
        System.out.println(s == s2);//jdk6：false   jdk7/8：false
        
        /*
         1、s3变量记录的地址为：new String("11")
         2、经过上面的分析，已经知道在堆中有了一个new String("11")这样的String对象，但是在字符串常量池中没有"11"
         3、接着执行s3.intern()，在字符串常量池中生成"11"
           3-1、在JDK6的版本中，字符串常量池还在永久代，所以直接在永久代生成"11",也就有了新的地址
           3-2、而在JDK7的后续版本中，字符串常量池被移动到了堆中，此时堆里已经有new String（"11"）了，出于节省空间的目的，直接将堆中的那个字符串的引用地址储存在字符串常量池中。没错，字符串常量池中存的是new String（"11"）在堆中的地址
         4、所以在JDK7后续版本中，s3和s4指向的完全是同一个地址。
         */
        String s3 = new String("1") + new String("1");//pos_1
        s3.intern();
        
        String s4 = "11";//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的"11"的地址
        System.out.println(s3 == s4);//jdk6：false  jdk7/8：true
    }

}
</code></pre>
<p>注：intern 方法堆中对象的地址引用！！</p>
<p>JDK6 中输出：</p>
<p>JAVA<br>1<br>2<br>false<br>false<br>JDK6 中输出：</p>
<p>JAVA<br>1<br>2<br>false<br>true<br>为什么输出会不一样呢？</p>
<p>JDK6 ：</p>
<p>一个是 new 创建的对象，一个是常量池中的对象，显然不是同一个；<br>new String () 即在堆中；<br>str.intern () 则把字符串放入常量池中。<br>JDK7 之后：</p>
<p>对 s3 和 s4 来说，因为 s3 变量记录的地址是 new String (“11”) ，然后这段代码执行完以后，常量池中不存在 “11”，然后执行 s3.intern () 后，就会在常量池中生成 “11”，最后 s4 用的就是 s3 的地址。<br>拓展一下：</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>/**</p>
<ul>
<li><p>StringIntern.java中练习的拓展：</p>
</li>
<li></li>
<li><p>/<br>public class StringIntern1 {<br>  public static void main(String[] args) {</p>
<pre><code>  //执行完下一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！
  String s3 = new String("1") + new String("1");//new String("11")
  //在字符串常量池中生成对象"11"，代码顺序换一下，实打实的在字符串常量池里有一个"11"对象
  String s4 = "11";  
  String s5 = s3.intern();

  // s3 是堆中的 "ab" ，s4 是字符串常量池中的 "ab"
  System.out.println(s3 == s4);//false

  // s5 是从字符串常量池中取回来的引用，当然和 s4 相等
  System.out.println(s5 == s4);//true
</code></pre>
<p>  }<br>}<br>intern () 方法的练习<br>练习 1：</p>
</li>
</ul>
<pre><code class="bash">public class StringExer1 {
    public static void main(String[] args) {
        String x = "ab";
        String s = new String("a") + new String("b");//new String("ab")
        //在上一行代码执行完以后，字符串常量池中并没有"ab"
        /*
        1、jdk6中：在字符串常量池（此时在永久代）中创建一个字符串"ab"
        2、jdk8中：字符串常量池（此时在堆中）中没有创建字符串"ab",而是创建一个引用，指向new String("ab")，将此引用返回
        3、详解看上面
        */
        String s2 = s.intern();

        System.out.println(s2 == "ab");//jdk6:true  jdk8:true
        System.out.println(s == "ab");//jdk6:false  jdk8:true
    }
}
</code></pre>
<p>JDK7/8：练习 2</p>
<pre><code class="bash">public class StringExer1 {
    public static void main(String[] args) { 
        String x = "ab";
        String s = new String("a") + new String("b");//new String("ab")

        String s2 = s.intern();

        System.out.println(s2 == "ab");//jdk6:true  jdk8:true
        System.out.println(s == "ab");//jdk6:false  jdk8:true
    }
}
</code></pre>
<p>练习 3</p>
<pre><code class="bash">public class StringExer2 {
    // 对象内存地址可以使用System.identityHashCode(object)方法获取
    public static void main(String[] args) {
        String s1 = new String("a") + new String("b");//执行完以后，不会在字符串常量池中会生成"ab"
        System.out.println(System.identityHashCode(s1));
        s1.intern();
        System.out.println(System.identityHashCode(s1));
        String s2 = "ab";
        System.out.println(System.identityHashCode(s2));
        System.out.println(s1 == s2); // true
    }
}
</code></pre>
<blockquote>
<p>输出结果：</p>
</blockquote>
<pre><code class="bash">1836019240
1836019240
1836019240
true
</code></pre>
<h2 id="intern-的效率测试（空间角度）"><a href="#intern-的效率测试（空间角度）" class="headerlink" title="intern () 的效率测试（空间角度）"></a>intern () 的效率测试（空间角度）</h2><p>示例代码：</p>
<pre><code class="bash">/**
 - 使用intern()测试执行效率：空间使用上
 -  3. 结论：对于程序中大量存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。
 -  */
public class StringIntern2 {
    static final int MAX_COUNT = 1000 * 10000;
    static final String[] arr = new String[MAX_COUNT];

    public static void main(String[] args) {
        Integer[] data = new Integer[]{1,2,3,4,5,6,7,8,9,10};

        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; MAX_COUNT; i++) {
//            arr[i] = new String(String.valueOf(data[i % data.length]));
            arr[i] = new String(String.valueOf(data[i % data.length])).intern();

        }
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为：" + (end - start));

        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.gc();
    }
}
</code></pre>
<p>直接 new String：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高；</p>
<p>使用 intern () 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低；</p>
<p>JAVA<br>1<br>2<br>//调用了intern()方法使用了字符串常量池里的字符串，那么前面堆里的字符串便会被GC掉，这也是intern省内存的关键原因<br>arr[i] = new String(String.valueOf(data[i % data.length])).intern();<br>结论：</p>
<p>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用 intern () 方法能够节省很大的内存空间。</p>
<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern () 方法，就会很明显降低内存的大小。</p>
<p>StringTable 的垃圾回收<br>示例代码：</p>
<pre><code class="bash">/**
 * String的垃圾回收:
 * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails
 */
public class StringGCTest {
    public static void main(String[] args) {
        for (int j = 0; j &lt; 100000; j++) {
            String.valueOf(j).intern();
        }
    }
}
</code></pre>
<blockquote>
<p>输出结果：在 PSYoungGen 区发生了垃圾回收。</p>
</blockquote>
<p>G1 中的 String 去重操作</p>
<p>官方文档：<a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/192">http://openjdk.java.net/jeps/192</a></p>
<p>String 去重操作的背景</p>
<p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的。</p>
<p>背景：对许多 Java 应用（有大的也有小的）做的测试得出以下结果：<br>堆存活数据集合里面 String 对象占了 25%；<br>堆存活数据集合里面重复的 String 对象有 13.5%；<br>String 对象的平均长度是 45。<br>许多大规模的 Java 应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java 堆中存活的数据集合差不多 25% 是 String 对象。更进一步，这里面差不多一半 String 对象是重复的，重复的意思是说：str1.equals (str2)=true。堆上存在重复的 String 对象必然是一种内存的浪费。这个项目将在 G1 垃圾收集器中实现自动持续对重复的 String 对象进行去重，这样就能避免浪费内存。<br>String 去重的的实现：</p>
<p>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的 String 对象；<br>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的 String 对象；<br>使用一个 Hashtable 来记录所有的被 String 对象使用的不重复的 char 数组。当去重的时候，会查这个 Hashtable ，来看堆上是否已经存在一个一模一样的 char 数组；<br>如果存在，String 对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉；<br>如果查找失败，char 数组会被插入到 Hashtable ，这样以后的时候就可以共享这个数组了。<br>命令行选项：</p>
<p>UseStringDeduplication (bool) ：开启 String 去重，默认是不开启的，需要手动开启。<br>PrintStringDeduplicationStatistics (bool) ：打印详细的去重统计信息。<br>stringDeduplicationAgeThreshold (uintx) ：达到这个年龄的 String 对象被认为是去重的候选对象。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">阿健君</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/10/27/jvm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/">http://example.com/2020/10/27/jvm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">HJ 的学习录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">内存分配</a><a class="post-meta__tags" href="/tags/intern/">intern</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/StringTable.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信扫码"></a><div class="post-qr-code-desc">微信扫码</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝扫码"></a><div class="post-qr-code-desc">支付宝扫码</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/31/jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210311093513473.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">对象的内存布局与访问定位</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/23/jvm/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/20210311111027982.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">本地方法接口与本地方法栈</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">阿健君</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>qq:1064821280</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/junian455" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1064821280@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://junian455.github.io/" target="_blank" title="Blog"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哈喽，有问题的话请在留言板留言，我看到会第一时间回复你。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">字符串常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#new-String-%E2%80%9Ca%E2%80%9D-new-String-%E2%80%9Cb%E2%80%9D-%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">new String (“a”) + new String (“b”) 会创建几个对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-text">String 对象在不同版本中的内存分析？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#intern-%E7%9A%84%E6%95%88%E7%8E%87%E6%B5%8B%E8%AF%95%EF%BC%88%E7%A9%BA%E9%97%B4%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-text">intern () 的效率测试（空间角度）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/collection/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86/" title="红黑树原理"><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/%E7%BA%A2%E9%BB%912%E6%A0%91.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红黑树原理"></a><div class="content"><a class="title" href="/2022/04/16/collection/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86/" title="红黑树原理">红黑树原理</a><time datetime="2022-04-16T02:55:00.000Z" title="发表于 2022-04-16 10:55:00">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/02/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式-行为型设计模式"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式-行为型设计模式"></a><div class="content"><a class="title" href="/2022/04/02/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式-行为型设计模式">设计模式-行为型设计模式</a><time datetime="2022-04-02T08:11:00.000Z" title="发表于 2022-04-02 16:11:00">2022-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/14/redis/%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%BB%E9%87%8D%EF%BC%9F/" title="怎么利用Redis实现数据的去重？"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/cache.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="怎么利用Redis实现数据的去重？"></a><div class="content"><a class="title" href="/2022/03/14/redis/%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%BB%E9%87%8D%EF%BC%9F/" title="怎么利用Redis实现数据的去重？">怎么利用Redis实现数据的去重？</a><time datetime="2022-03-14T06:29:00.000Z" title="发表于 2022-03-14 14:29:00">2022-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/sql/select%EF%BC%8A%E5%92%8C%20select%20%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" title="select＊和 select 全部字段，它们的区别是什么？"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/es1.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="select＊和 select 全部字段，它们的区别是什么？"></a><div class="content"><a class="title" href="/2022/03/01/sql/select%EF%BC%8A%E5%92%8C%20select%20%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" title="select＊和 select 全部字段，它们的区别是什么？">select＊和 select 全部字段，它们的区别是什么？</a><time datetime="2022-03-01T02:55:00.000Z" title="发表于 2022-03-01 10:55:00">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/SEATA/" title="SEATA"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/seata.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SEATA"></a><div class="content"><a class="title" href="/2022/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/SEATA/" title="SEATA">SEATA</a><time datetime="2022-01-20T07:11:00.000Z" title="发表于 2022-01-20 15:11:00">2022-01-20</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2022 By 阿健君</div><div class="footer_custom_text"><span style="margin-top:5px;display:inline-block;font-weight:bold;font-size:14px">一分耕耘，一分收获。</span><p></p> <p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架为Hexo" data-ll-status="loading" class="entered loading"></a>&nbsp;<a target="_blank" href="https://demo.jerryc.me/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题采用butterfly" data-ll-status="loading" class="entered loading"></a>&nbsp;<a target="_blank" href="https://metroui.org.ua/index.html "><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速" data-ll-status="loading" class="entered loading"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&amp;logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel" data-ll-status="loading" class="entered loading"></a>&nbsp;<a class="github-badge" target="_blank" href="https://beian.miit.gov.cn" style="margin-inline:5px" title="本站已在工信部备案，备案号浙ICP备-2022001668号"><img src="http://cdn.ymktchic.top/img/202201212329189.svg" data-lazy-src="" alt="" data-ll-status="loaded" class="entered loaded"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" data-ll-status="loading" class="entered loading"></a> <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="95" height="20" role="img" aria-label="CDN:又拍云"><title>CDN:又拍云</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"></stop><stop offset="1" stop-opacity=".1"></stop></linearGradient><clipPath id="r"><rect width="95" height="20" rx="3" fill="#fff"></rect></clipPath><g clip-path="url(#r)"><rect width="52" height="20" fill="#555"></rect><rect x="52" width="43" height="20" fill="#00b6ff"></rect><rect width="95" height="20" fill="url(#s)"></rect></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><image x="5" y="3" width="14" height="14" xlink:href="https://developer.qiniu.com/assets/logo-white-b90d685a6b146884636382426d11b7236f5f7ca1c5dfafdb6fa777a0f976fc1f.png"></image><text aria-hidden="true" x="355" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="250">CDN</text><text x="355" y="140" transform="scale(.1)" fill="#fff" textLength="250">CDN</text><text aria-hidden="true" x="725" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="330">七牛云</text><text x="725" y="140" transform="scale(.1)" fill="#fff" textLength="330">七牛云</text></g></svg></p></div></div><div class="container" id="jsi-flying-fish-container"></div><style>@media only screen and (max-width: 767px){
  #sidebar_search_box input[type=text]{width:calc(100% - 24px)}
}</style></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2020/10/27/jvm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/'
    this.page.identifier = '2020/10/27/jvm/字符串常量池/'
    this.page.title = '字符串常量池'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="/js/card_categor_hide.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script data-pjax="" src="https://cdn.jsdelivr.net/gh/Jnylife/CDN@1.3/js/fish.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/WithoutLine.min.js"></script><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>