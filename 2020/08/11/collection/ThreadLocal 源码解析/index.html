<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ThreadLocal 源码解析 | HJ 的学习录</title><meta name="keywords" content="ThreadLocalMap,set,key 过期清理策略"><meta name="author" content="阿健君"><meta name="copyright" content="阿健君"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="ThreadLocal前言 问题： ThreadLocal 的 key 是弱引用，那么在 ThreadLocal.get () 的时候，发生 GC 之后，key 是否为 null？ThreadLocal 中 ThreadLocalMap 的数据结构？ThreadLocalMap 的 Hash 算法？ThreadLocalMap 中 Hash 冲突如何解决？ThreadLocalMap 的扩容机制？">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadLocal 源码解析">
<meta property="og:url" content="http://example.com/2020/08/11/collection/ThreadLocal%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="HJ 的学习录">
<meta property="og:description" content="ThreadLocal前言 问题： ThreadLocal 的 key 是弱引用，那么在 ThreadLocal.get () 的时候，发生 GC 之后，key 是否为 null？ThreadLocal 中 ThreadLocalMap 的数据结构？ThreadLocalMap 的 Hash 算法？ThreadLocalMap 中 Hash 冲突如何解决？ThreadLocalMap 的扩容机制？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/6.png">
<meta property="article:published_time" content="2020-08-11T03:05:00.000Z">
<meta property="article:modified_time" content="2020-08-11T03:05:00.000Z">
<meta property="article:author" content="阿健君">
<meta property="article:tag" content="ThreadLocalMap">
<meta property="article:tag" content="set">
<meta property="article:tag" content="key 过期清理策略">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/6.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/08/11/collection/ThreadLocal%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ThreadLocal 源码解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: false,
  postUpdate: '2020-08-11 11:05:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/scollbar.css"><link rel="stylesheet" href="/css/bottomsetting.css"><link rel="stylesheet" href="/css/card_categor_hide.css"><link rel="stylesheet" href="/css/article_bak_transparent.css"><link rel="stylesheet" href="/css/index_tag.css"><link rel="stylesheet" href="/css/index_tag2.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/index_tag3.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">105</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-th-large"></i><span> 百宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-user-shield"></i><span> 评论管理</span></a></li><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-cloud"></i><span> 我的云盘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-photo-video"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-child"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fa-fw fas fa-user-friends"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa-fw fas fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/6.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HJ 的学习录</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-th-large"></i><span> 百宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-user-shield"></i><span> 评论管理</span></a></li><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-cloud"></i><span> 我的云盘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-photo-video"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-child"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fa-fw fas fa-user-friends"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa-fw fas fa-comments"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ThreadLocal 源码解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-11T03:05:00.000Z" title="发表于 2020-08-11 11:05:00">2020-08-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-11T03:05:00.000Z" title="更新于 2020-08-11 11:05:00">2020-08-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9B%86%E5%90%88/">集合</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ThreadLocal 源码解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/6.png');"></div><article class="post-content" id="article-container"><p>ThreadLocal<br>前言</p>
<p>问题：</p>
<p>ThreadLocal 的 key 是弱引用，那么在 ThreadLocal.get () 的时候，发生 GC 之后，key 是否为 null？<br>ThreadLocal 中 ThreadLocalMap 的数据结构？<br>ThreadLocalMap 的 Hash 算法？<br>ThreadLocalMap 中 Hash 冲突如何解决？<br>ThreadLocalMap 的扩容机制？<br>ThreadLocalMap 中过期 key 的清理机制？探测式清理和启发式清理流程？<br>ThreadLocalMap.set() 方法实现原理？<br>ThreadLocalMap.get() 方法实现原理？<br>项目中 ThreadLocal 使用情况？遇到的坑？<br>……<br>ThreadLocal 代码演示<br>ThreadLocal 使用示例：</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>public class ThreadLocalTest {<br>    private List<string> messages = Lists.newArrayList();</string></p>
<pre><code>public static final ThreadLocal&lt;ThreadLocalTest&gt; holder = ThreadLocal.withInitial(ThreadLocalTest::new);

public static void add(String message) {
    holder.get().messages.add(message);
}

public static List&lt;String&gt; clear() {
    List&lt;String&gt; messages = holder.get().messages;
    holder.remove();

    System.out.println("size: " + holder.get().messages.size());
    return messages;
}

public static void main(String[] args) {
    ThreadLocalTest.add("哈哈");
    System.out.println(holder.get().messages);
    ThreadLocalTest.clear();
}
</code></pre>
<p>}<br>打印结果：</p>
<p>CODE<br>1<br>2<br>[哈哈]<br>size: 0<br>ThreadLocal 对象可以提供线程局部变量，每个线程 Thread 拥有一份自己的副本变量，多个线程互不干扰。</p>
<p>ThreadLocal 的数据结构</p>
<p>img</p>
<p>Thread 类有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals，也就是说每个线程有一个自己的 ThreadLocalMap。</p>
<p>ThreadLocalMap 有自己的独立实现，可以简单地将它的 key 视作 ThreadLocal，value 为代码中放入的值（实际上 key 并不是 ThreadLocal 本身，而是它的一个弱引用）。</p>
<p>每个线程在往 ThreadLocal 里放值的时候，都会往自己的 ThreadLocalMap 里存，读也是以 ThreadLocal 作为引用，在自己的 map 里找对应的 key，从而实现了线程隔离。</p>
<p>ThreadLocalMap 有点类似 HashMap 的结构，只是 HashMap 是由数组 + 链表实现的，而 ThreadLocalMap 中并没有链表结构。</p>
<p>我们还要注意 Entry， 它的 key 是 ThreadLocal&lt;?&gt; k ，继承自 WeakReference， 也就是我们常说的弱引用类型。</p>
<p>GC 之后 key 是否为 null？<br>Java 的四种引用类型：</p>
<p>强引用：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候。<br>软引用：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收。<br>弱引用：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收。<br>虚引用：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知。<br>使用反射的方式来看看 GC 后 ThreadLocal 中的数据情况：</p>
<pre><code class="bash">public class ThreadLocalDemo {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InterruptedException {
        Thread t = new Thread(()-&gt;test("abc",false));
        t.start();
        t.join();
        System.out.println("--gc后--");
        Thread t2 = new Thread(() -&gt; test("def", true));
        t2.start();
        t2.join();
    }

    private static void test(String s,boolean isGC)  {
        try {
            new ThreadLocal&lt;&gt;().set(s);
            if (isGC) {
                System.gc();
            }
            Thread t = Thread.currentThread();
            Class&lt;? extends Thread&gt; clz = t.getClass();
            Field field = clz.getDeclaredField("threadLocals");
            field.setAccessible(true);
            Object ThreadLocalMap = field.get(t);
            Class&lt;?&gt; tlmClass = ThreadLocalMap.getClass();
            Field tableField = tlmClass.getDeclaredField("table");
            tableField.setAccessible(true);
            Object[] arr = (Object[]) tableField.get(ThreadLocalMap);
            for (Object o : arr) {
                if (o != null) {
                    Class&lt;?&gt; entryClass = o.getClass();
                    Field valueField = entryClass.getDeclaredField("value");
                    Field referenceField = entryClass.getSuperclass().getSuperclass().getDeclaredField("referent");
                    valueField.setAccessible(true);
                    referenceField.setAccessible(true);
                    System.out.println(String.format("弱引用key:%s,值:%s", referenceField.get(o), valueField.get(o)));
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>结果如下：</p>
<pre><code class="bash">弱引用key:java.lang.ThreadLocal@433619b6,值:abc
弱引用key:java.lang.ThreadLocal@418a15e3,值:java.lang.ref.SoftReference@bf97a12
--gc后--
弱引用key:null,值:def
</code></pre>
<p>img</p>
<p>如图所示，因为这里创建的 ThreadLocal 并没有指向任何值，也就是没有任何引用：</p>
<p>JAVA<br>1<br>new ThreadLocal&lt;&gt;().set(s);<br>所以这里在 GC 之后，key 就会被回收，我们看到上面 debug 中的 referent=null, 如果改动一下代码：</p>
<p>img</p>
<p>这个问题刚开始看，如果没有过多思考，弱引用，还有垃圾回收，那么肯定会觉得是 null。其实是不对的，因为题目说的是在做 ThreadLocal.get() 操作，证明其实还是有强引用存在的，所以 key 并不为 null，如下图所示，ThreadLocal 的强引用仍然是存在的。</p>
<p>image.png</p>
<p>如果我们的强引用不存在的话，那么 key 就会被回收，也就是会出现我们 value 没被回收，key 被回收，导致 value 永远存在，出现内存泄漏。</p>
<p>ThreadLocal.set() 方法源码详解</p>
<p>img</p>
<p>ThreadLocal 中的 set 方法原理如上图所示，很简单，主要是判断 ThreadLocalMap 是否存在，然后使用 ThreadLocal 中的 set 方法进行数据处理。</p>
<p>代码如下：</p>
<pre><code class="bash">public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}

void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
</code></pre>
<p>主要的核心逻辑还是在 ThreadLocalMap 中的，一步步往下看，后面还有更详细的剖析。</p>
<p>ThreadLocalMap Hash 算法<br>既然是 Map 结构，那么 ThreadLocalMap 当然也要实现自己的 hash 算法来解决散列表数组冲突问题。</p>
<p>JAVA<br>1<br>int i = key.threadLocalHashCode &amp; (len-1);<br>ThreadLocalMap 中 hash 算法很简单，这里 i 就是当前 key 在散列表中对应的数组下标位置。</p>
<p>这里最关键的就是 threadLocalHashCode 值的计算，ThreadLocal 中有一个属性为 HASH_INCREMENT = 0x61c88647</p>
<pre><code class="bash">public class ThreadLocal&lt;T&gt; {
    private final int threadLocalHashCode = nextHashCode();

    private static AtomicInteger nextHashCode = new AtomicInteger();

    private static final int HASH_INCREMENT = 0x61c88647;

    private static int nextHashCode() {
        return nextHashCode.getAndAdd(HASH_INCREMENT);
    }

    static class ThreadLocalMap {
        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {
            table = new Entry[INITIAL_CAPACITY];
            int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);

            table[i] = new Entry(firstKey, firstValue);
            size = 1;
            setThreshold(INITIAL_CAPACITY);
        }
    }
}
</code></pre>
<p>每当创建一个 ThreadLocal 对象，这个 ThreadLocal.nextHashCode 这个值就会增长 0x61c88647 。</p>
<p>这个值很特殊，它是斐波那契数 也叫 黄金分割数。hash 增量为 这个数字，带来的好处就是 hash 分布非常均匀。</p>
<p>我们自己可以尝试下：</p>
<p>img</p>
<p>可以看到产生的哈希码分布很均匀，这里不去细纠斐波那契具体算法，感兴趣的可以自行查阅相关资料。</p>
<p>ThreadLocalMap Hash 冲突<br>注明： 下面所有示例图中，绿色块Entry 代表正常数据，灰色块代表 Entry 的 key 值为 null，已被垃圾回收。白色块表示 Entry 为 null。</p>
<p>虽然 ThreadLocalMap 中使用了黄金分割数来作为 hash 计算因子，大大减少了 Hash 冲突的概率，但是仍然会存在冲突。</p>
<p>HashMap 中解决冲突的方法是在数组上构造一个链表结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成红黑树。而 ThreadLocalMap 中并没有链表结构，所以这里不能使用 HashMap 解决冲突的方式了。</p>
<p>img</p>
<p>如上图所示，如果我们插入一个 value=27 的数据，通过 hash 计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry 数据。</p>
<p>此时就会线性向后查找，一直找到 Entry 为 null 的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了 Entry 不为 null 且 key 值相等的情况，还有 Entry 中的 key 值为 null 的情况等等都会有不同的处理，后面会一一详细讲解。</p>
<p>这里还画了一个 Entry 中的 key 为 null 的数据（Entry=2 的灰色块数据），因为 key 值是弱引用类型，所以会有这种数据存在。在 set 过程中，如果遇到了 key 过期的 Entry 数据，实际上是会进行一轮探测式清理操作的，具体操作方式后面会讲到。</p>
<p>ThreadLocalMap.set() 详解<br>ThreadLocalMap.set() 原理图解<br>看完了 ThreadLocal hash 算法后，我们再来看 set 是如何实现的。往 ThreadLocalMap 中 set 数据（新增或者更新数据）分为好几种情况，针对不同的情况我们画图来说说明。</p>
<p>第一种情况： 通过 hash 计算后的槽位对应的 Entry 数据为空：这里直接将数据放到该槽位即可。</p>
<p>img</p>
<p>第二种情况： 槽位数据不为空，key 值与当前 ThreadLocal 通过 hash 计算获取的 key 值一致：这里直接更新该槽位的数据。</p>
<p>img</p>
<p>第三种情况： 槽位数据不为空，往后遍历过程中，在找到 Entry 为 null 的槽位之前，没有遇到 key 过期的 Entry：</p>
<p>img</p>
<p>遍历散列数组，线性往后查找，如果找到 Entry 为 null 的槽位，则将数据放入该槽位中，或者往后遍历过程中，遇到了 key 值相等的数据，直接更新即可。</p>
<p>第四种情况： 槽位数据不为空，往后遍历过程中，在找到 Entry 为 null 的槽位之前，遇到 key 过期的 Entry，如下图，往后遍历过程中，一到了 index=7 的槽位数据 Entry 的 key=null：</p>
<p>img</p>
<p>散列数组下标为 7 位置对应的 Entry 数据 key 为 null，表明此数据 key 值已经被垃圾回收掉了，此时就会执行 replaceStaleEntry() 方法，该方法含义是替换过期数据的逻辑，以 index=7 位起点开始遍历，进行探测式数据清理工作。</p>
<p>初始化探测式清理过期数据扫描的开始位置：slotToExpunge = staleSlot = 7；</p>
<p>以当前 staleSlot 开始向前迭代查找，找其他过期的数据，然后更新过期数据起始扫描下标 slotToExpunge。for 循环迭代，直到碰到 Entry 为 null 结束。</p>
<p>如果找到了过期的数据，继续向前迭代，直到遇到 Entry=null 的槽位才停止迭代，如下图所示，slotToExpunge 被更新为 0：</p>
<p>img</p>
<p>以当前节点 (index=7) 向前迭代，检测是否有过期的 Entry 数据，如果有则更新 slotToExpunge 值。碰到 null 则结束探测。以上图为例 slotToExpunge 被更新为 0。</p>
<p>上面向前迭代的操作是为了更新探测清理过期数据的起始下标 slotToExpunge 的值，这个值在后面会讲解，它是用来判断当前过期槽位 staleSlot 之前是否还有过期元素。</p>
<p>接着开始以 staleSlot 位置 (index=7) 向后迭代，如果找到了相同 key 值的 Entry 数据：</p>
<p>img</p>
<p>从当前节点 staleSlot 向后查找 key 值相等的 Entry 元素，找到后更新 Entry 的值并交换 staleSlot 元素的位置 (staleSlot 位置为过期元素)，更新 Entry 数据，然后开始进行过期 Entry 的清理工作，如下图所示：</p>
<p>img<br>向后遍历过程中，如果没有找到相同 key 值的 Entry 数据：</p>
<p>img</p>
<p>从当前节点 staleSlot 向后查找 key 值相等的 Entry 元素，直到 Entry 为 null 则停止寻找。通过上图可知，此时 table 中没有 key 值相同的 Entry。</p>
<p>创建新的 Entry，替换 table[stableSlot] 位置：</p>
<p>img</p>
<p>替换完成后也是进行过期元素清理工作，清理工作主要是有两个方法：expungeStaleEntry() 和 cleanSomeSlots()，具体细节后面会讲到，请继续往后看。</p>
<p>ThreadLocalMap.set() 源码详解<br>上面已经用图的方式解析了 set() 实现的原理，其实已经很清晰了，我们接着再看下源码：</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.set():</p>
<pre><code class="bash">private void set(ThreadLocal&lt;?&gt; key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len-1);

    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&lt;?&gt; k = e.get();

        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
        rehash();
}
</code></pre>
<blockquote>
<p>这里会通过 key 来计算在散列表中的对应位置，然后以当前 key 对应的桶的位置向后查找，找到可以使用的桶。</p>
</blockquote>
<pre><code class="bash">Entry[] tab = table;
int len = tab.length;
int i = key.threadLocalHashCode &amp; (len-1);
</code></pre>
<p>什么情况下桶才是可以使用的呢？</p>
<p>k = key 说明是替换操作，可以使用；<br>碰到一个过期的桶，执行替换逻辑，占用过期桶；<br>查找过程中，碰到桶中 Entry=null 的情况，直接使用。<br>接着就是执行 for 循环遍历，向后查找，我们先看下 nextIndex()、prevIndex() 方法实现：</p>
<p>img</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>private static int nextIndex(int i, int len) {<br>    return ((i + 1 &lt; len) ? i + 1 : 0);<br>}</p>
<p>private static int prevIndex(int i, int len) {<br>    return ((i - 1 &gt;= 0) ? i - 1 : len - 1);<br>}<br>接着看剩下 for 循环中的逻辑：</p>
<p>遍历当前 key 值对应的桶中 Entry 数据为空，这说明散列数组这里没有数据冲突，跳出 for 循环，直接 set 数据到对应的桶中；<br>如果 key 值对应的桶中 Entry 数据不为空 ：<br>如果 k = key，说明当前 set 操作是一个替换操作，做替换逻辑，直接返回 ；<br>如果 key = null，说明当前桶位置的 Entry 是过期数据，执行 replaceStaleEntry() 方法 (核心方法)，然后返回。<br>for 循环执行完毕，继续往下执行说明向后迭代的过程中遇到了 entry 为 null 的情况 ：<br>在 Entry 为 null 的桶中创建一个新的 Entry 对象 ；<br>执行 ++size 操作。<br>调用 cleanSomeSlots() 做一次启发式清理工作，清理散列数组中 Entry 的 key 过期的数据<br>如果清理工作完成后，未清理到任何数据，且 size 超过了阈值 (数组长度的 2/3)，进行 rehash() 操作 ；<br>rehash() 中会先进行一轮探测式清理，清理过期 key，清理完成后如果 size &gt;= threshold - threshold / 4，就会执行真正的扩容逻辑 (扩容逻辑往后看)。<br>接着重点看下 replaceStaleEntry() 方法，replaceStaleEntry() 方法提供替换过期数据的功能，可以对应上面第四种情况的原理图来再回顾下，具体代码如下：</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.replaceStaleEntry():</p>
<pre><code class="bash">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,
                                       int staleSlot) {
    Entry[] tab = table;
    int len = tab.length;
    Entry e;

    int slotToExpunge = staleSlot;
    for (int i = prevIndex(staleSlot, len);
         (e = tab[i]) != null;
         i = prevIndex(i, len))

        if (e.get() == null)
            slotToExpunge = i;

    for (int i = nextIndex(staleSlot, len);
         (e = tab[i]) != null;
         i = nextIndex(i, len)) {

        ThreadLocal&lt;?&gt; k = e.get();

        if (k == key) {
            e.value = value;

            tab[i] = tab[staleSlot];
            tab[staleSlot] = e;

            if (slotToExpunge == staleSlot)
                slotToExpunge = i;
            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
            return;
        }

        if (k == null &amp;&amp; slotToExpunge == staleSlot)
            slotToExpunge = i;
    }

    tab[staleSlot].value = null;
    tab[staleSlot] = new Entry(key, value);

    if (slotToExpunge != staleSlot)
        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
}
</code></pre>
<p>//slotToExpunge<code>表示开始探测式清理过期数据的开始下标，默认从当前的</code>staleSlot<code>开始。以当前的</code>staleSlot<code>开始，向前迭代查找，找到没有过期的数据，</code>for<code>循环一直碰到</code>Entry<code>为</code>null<code>才会结束。如果向前找到了过期数据，更新探测清理过期数据的开始下标为 i，即</code>slotToExpunge=i<br>for (int i = prevIndex(staleSlot, len);<br>     (e = tab[i]) != null;<br>     i = prevIndex(i, len)){</p>
<pre><code>if (e.get() == null){
    slotToExpunge = i;
}
</code></pre>
<p>}<br>接着开始从 staleSlot 向后查找，也是碰到 Entry 为 null 的桶结束。 如果迭代过程中，碰到 k == key，这说明这里是替换逻辑，替换新数据并且交换当前 staleSlot 位置。如果 slotToExpunge == staleSlot，这说明 replaceStaleEntry() 一开始向前查找过期数据时并未找到过期的 Entry 数据，接着向后查找过程中也未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的 index，即 slotToExpunge = i。最后调用 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); 进行启发式过期数据清理。</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>if (k == key) {<br>    e.value = value;</p>
<pre><code>tab[i] = tab[staleSlot];
tab[staleSlot] = e;

if (slotToExpunge == staleSlot)
    slotToExpunge = i;

cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
return;
</code></pre>
<p>}<br>cleanSomeSlots() 和 expungeStaleEntry() 方法后面都会细讲，这两个是和清理相关的方法，一个是过期 key 相关 Entry 的启发式清理 (Heuristically scan)，另一个是过期 key 相关 Entry 的探测式清理。</p>
<p>如果 k != key 则会接着往下走，k == null 说明当前遍历的 Entry 是一个过期数据，slotToExpunge == staleSlot 说明，一开始的向前查找数据并未找到过期的 Entry。如果条件成立，则更新 slotToExpunge 为当前位置，这个前提是前驱节点扫描时未发现过期数据。</p>
<p>JAVA<br>1<br>2<br>if (k == null &amp;&amp; slotToExpunge == staleSlot)<br>    slotToExpunge = i;<br>往后迭代的过程中如果没有找到 k == key 的数据，且碰到 Entry 为 null 的数据，则结束当前的迭代操作。此时说明这里是一个添加的逻辑，将新的数据添加到 table[staleSlot] 对应的 slot 中。</p>
<p>JAVA<br>1<br>2<br>tab[staleSlot].value = null;<br>tab[staleSlot] = new Entry(key, value);<br>最后判断除了 staleSlot 以外，还发现了其他过期的 slot 数据，就要开启清理数据的逻辑：</p>
<p>JAVA<br>1<br>2<br>if (slotToExpunge != staleSlot)<br>    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>ThreadLocalMap 过期 key 的探测式清理流程<br>上面提及 ThreadLocalMap 的两种过期 key 数据清理方式：探测式清理和启发式清理。</p>
<p>我们先讲下探测式清理，也就是 expungeStaleEntry 方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的 Entry 设置为 null，沿途中碰到未过期的数据则将此数据 rehash 后重新在 table 数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的 Entry=null 的桶中，使 rehash 后的 Entry 数据距离正确的桶的位置更近一些。操作逻辑如下：</p>
<p>img</p>
<p>如上图，set(27) 经过 hash 计算后应该落到 index=4 的桶中，由于 index=4 桶已经有了数据，所以往后迭代最终数据放入到 index=7 的桶中，放入后一段时间后 index=5 中的 Entry 数据 key 变为了 null。</p>
<p>img</p>
<p>如果再有其他数据 set 到 map 中，就会触发探测式清理操作。如上图，执行探测式清理后，index=5 的数据被清理掉，继续往后迭代，到 index=7 的元素时，经过 rehash 后发现该元素正确的 index=4，而此位置已经已经有了数据，往后查找离 index=4 最近的 Entry=null 的节点 (刚被探测式清理掉的数据：index=5)，找到后移动 index= 7 的数据到 index=5 中，此时桶的位置离正确的位置 index=4 更近了。</p>
<p>经过一轮探测式清理后，key 过期的数据会被清理掉，没过期的数据经过 rehash 重定位后所处的桶位置理论上更接近 i= key.hashCode &amp; (tab.len - 1) 的位置。这种优化会提高整个散列表查询性能。</p>
<p>接着看下 expungeStaleEntry() 具体流程，我们还是以先原理图后源码讲解的方式来一步步梳理：</p>
<p>img</p>
<p>假设 expungeStaleEntry(3) 来调用此方法，如上图所示，我们可以看到 ThreadLocalMap 中 table 的数据情况，接着执行清理操作：</p>
<p>img</p>
<p>第一步是清空当前 staleSlot 位置的数据，index=3 位置的 Entry 变成了 null。然后接着往后探测：</p>
<p>img</p>
<p>执行完第二步后，index=4 的元素挪到 index=3 的槽位中。继续往后迭代检查，碰到正常数据，计算该数据位置是否偏移，如果被偏移，则重新计算 slot 位置，目的是让正常数据尽可能存放在正确位置或离正确位置更近的位置</p>
<p>img</p>
<p>在往后迭代的过程中碰到空的槽位，终止探测，这样一轮探测式清理工作就完成了，接着我们继续看看具体实现源代码：</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>private int expungeStaleEntry(int staleSlot) {<br>    Entry[] tab = table;<br>    int len = tab.length;</p>
<pre><code>tab[staleSlot].value = null;
tab[staleSlot] = null;
size--;

Entry e;
int i;
for (i = nextIndex(staleSlot, len);
     (e = tab[i]) != null;
     i = nextIndex(i, len)) {
    ThreadLocal&lt;?&gt; k = e.get();
    if (k == null) {
        e.value = null;
        tab[i] = null;
        size--;
    } else {
        int h = k.threadLocalHashCode &amp; (len - 1);
        if (h != i) {
            tab[i] = null;

            while (tab[h] != null)
                h = nextIndex(h, len);
            tab[h] = e;
        }
    }
}
return i;
</code></pre>
<p>}<br>这里我们还是以 staleSlot=3 来做示例说明，首先是将 tab[staleSlot] 槽位的数据清空，然后设置 size– 接着以 staleSlot 位置往后迭代，如果遇到 k==null 的过期数据，也是清空该槽位数据，然后 size–</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>ThreadLocal&lt;?&gt; k = e.get();</p>
<p>if (k == null) {<br>    e.value = null;<br>    tab[i] = null;<br>    size–;<br>}<br>如果 key 没有过期，重新计算当前 key 的下标位置是不是当前槽位下标位置，如果不是，那么说明产生了 hash 冲突，此时以新计算出来正确的槽位位置往后迭代，找到最近一个可以存放 entry 的位置。</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>int h = k.threadLocalHashCode &amp; (len - 1);<br>if (h != i) {<br>    tab[i] = null;</p>
<pre><code>while (tab[h] != null)
    h = nextIndex(h, len);

tab[h] = e;
</code></pre>
<p>}<br>这里是处理正常的产生 Hash 冲突的数据，经过迭代后，有过 Hash 冲突数据的 Entry 位置会更靠近正确位置，这样的话，查询的时候 效率才会更高。</p>
<p>ThreadLocalMap 扩容机制<br>在 ThreadLocalMap.set() 方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中 Entry 的数量已经达到了列表的扩容阈值 (len*2/3)，就开始执行 rehash() 逻辑：</p>
<p>JAVA<br>1<br>2<br>if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>    rehash();<br>接着看下 rehash() 具体实现：</p>
<pre><code class="bash">private void rehash() {
    expungeStaleEntries();

    if (size &gt;= threshold - threshold / 4)
        resize();
}

private void expungeStaleEntries() {
    Entry[] tab = table;
    int len = tab.length;
    for (int j = 0; j &lt; len; j++) {
        Entry e = tab[j];
        if (e != null &amp;&amp; e.get() == null)
            expungeStaleEntry(j);
    }
}
</code></pre>
<p>这里首先是会进行探测式清理工作，从 table 的起始位置往后清理，上面有分析清理的详细流程。清理完成之后，table 中可能有一些 key 为 null 的 Entry 数据被清理掉，所以此时通过判断 size &gt;= threshold - threshold / 4 也就是 size &gt;= threshold* 3/4 来决定是否扩容。</p>
<p>还记得上面进行 rehash() 的阈值是 size &gt;= threshold，所以当面试官套路我们 ThreadLocalMap 扩容机制的时候，一定要说清楚这两个步骤：</p>
<p>img</p>
<p>接着看看具体的 resize() 方法，为了方便演示，以 oldTab.len=8 来举例：</p>
<p>img</p>
<p>扩容后的 tab 的大小为 oldLen * 2，然后遍历老的散列表，重新计算 hash 位置，然后放到新的 tab 数组中，如果出现 hash 冲突则往后寻找最近的 entry 为 null 的槽位，遍历完成之后，oldTab 中所有的 entry 数据都已经放入到新的 tab 中了。重新计算 tab 下次扩容的阈值，具体代码如下：</p>
<pre><code class="bash">private void resize() {
    Entry[] oldTab = table;
    int oldLen = oldTab.length;
    int newLen = oldLen * 2;
    Entry[] newTab = new Entry[newLen];
    int count = 0;

    for (int j = 0; j &lt; oldLen; ++j) {
        Entry e = oldTab[j];
        if (e != null) {
            ThreadLocal&lt;?&gt; k = e.get();
            if (k == null) {
                e.value = null;
            } else {
                int h = k.threadLocalHashCode &amp; (newLen - 1);
                while (newTab[h] != null)
                    h = nextIndex(h, newLen);
                newTab[h] = e;
                count++;
            }
        }
    }

    setThreshold(newLen);
    size = count;
    table = newTab;
}
</code></pre>
<p>ThreadLocalMap.get() 详解<br>ThreadLocalMap.get() 图解<br>第一种情况： 通过查找 key 值计算出散列表中 slot 位置，然后该 slot 位置中的 Entry.key 和查找的 key 一致，则直接返回：</p>
<p>img</p>
<p>第二种情况： slot 位置中的 Entry.key 和要查找的 key 不一致：</p>
<p>img</p>
<p>我们以 get(ThreadLocal1) 为例，通过 hash 计算后，正确的 slot 位置应该是 4，而 index=4 的槽位已经有了数据，且 key 值不等于 ThreadLocal1，所以需要继续往后迭代查找。</p>
<p>迭代到 index=5 的数据时，此时 Entry.key=null，触发一次探测式数据回收操作，执行 expungeStaleEntry() 方法，执行完后，index 5,8 的数据都会被回收，而 index 6,7 的数据都会前移，此时继续往后迭代，到 index = 6 的时候即找到了 key 值相等的 Entry 数据，如下图所示：</p>
<p>img</p>
<p>ThreadLocalMap.get() 源码详解<br>java.lang.ThreadLocal.ThreadLocalMap.getEntry():</p>
<pre><code class="bash">private Entry getEntry(ThreadLocal&lt;?&gt; key) {
    int i = key.threadLocalHashCode &amp; (table.length - 1);
    Entry e = table[i];
    if (e != null &amp;&amp; e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}

private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;

    while (e != null) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key)
            return e;
        if (k == null)
            expungeStaleEntry(i);
        else
            i = nextIndex(i, len);
        e = tab[i];
    }
    return null;
}
</code></pre>
<p>ThreadLocalMap 过期 key 的启发式清理流程<br>上面多次提及到 ThreadLocalMap 过期可以的两种清理方式：探测式清理 (expungeStaleEntry ())、启发式清理 (cleanSomeSlots ())。</p>
<p>探测式清理是以当前 Entry 往后清理，遇到值为 null 则结束清理，属于线性探测清理。</p>
<p>而启发式清理被作者定义为：Heuristically scan some cells looking for stale entries.</p>
<p>img</p>
<p>具体代码如下：</p>
<pre><code class="bash">private boolean cleanSomeSlots(int i, int n) {
    boolean removed = false;
    Entry[] tab = table;
    int len = tab.length;
    do {
        i = nextIndex(i, len);
        Entry e = tab[i];
        if (e != null &amp;&amp; e.get() == null) {
            n = len;
            removed = true;
            i = expungeStaleEntry(i);
        }
    } while ( (n &gt;&gt;&gt;= 1) != 0);
    return removed;
}
</code></pre>
<p>InheritableThreadLocal<br>我们使用 ThreadLocal 的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。</p>
<p>为了解决这个问题，JDK 中还有一个 InheritableThreadLocal 类，我们来看一个例子：</p>
<pre><code class="bash">public class InheritableThreadLocalDemo {
    public static void main(String[] args) {
        ThreadLocal&lt;String&gt; ThreadLocal = new ThreadLocal&lt;&gt;();
        ThreadLocal&lt;String&gt; inheritableThreadLocal = new InheritableThreadLocal&lt;&gt;();
        ThreadLocal.set("父类数据:threadLocal");
        inheritableThreadLocal.set("父类数据:inheritableThreadLocal");

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("子线程获取父类ThreadLocal数据：" + ThreadLocal.get());
                System.out.println("子线程获取父类inheritableThreadLocal数据：" + inheritableThreadLocal.get());
            }
        }).start();
    }
}
</code></pre>
<p>打印结果：</p>
<p>JAVA<br>1<br>2<br>子线程获取父类ThreadLocal数据：null<br>子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocal<br>实现原理是子线程是通过在父线程中通过调用 new Thread() 方法来创建子线程，Thread#init 方法在 Thread 的构造方法中被调用。在 init 方法中拷贝父线程数据到子线程中：</p>
<pre><code class="bash">private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc,
                      boolean inheritThreadLocals) {
    if (name == null) {
        throw new NullPointerException("name cannot be null");
    }

    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    this.stackSize = stackSize;
    tid = nextThreadID();
}
</code></pre>
<p>但 InheritableThreadLocal 仍然有缺陷，一般我们做异步化处理都是使用的线程池，而 InheritableThreadLocal 是在 new Thread 中的 init() 方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。</p>
<p>ThreadLocal 项目中使用实战<br>ThreadLocal 使用场景<br>我们现在项目中日志记录用的是 ELK+Logstash，最后在 Kibana 中进行展示和检索。现在都是分布式系统统一对外提供服务，项目间调用的关系可以通过 traceId 来关联，但是不同项目之间如何传递 traceId 呢？</p>
<p>这里我们使用 org.slf4j.MDC 来实现此功能，内部就是通过 ThreadLocal 来实现的，具体实现如下：</p>
<p>当前端发送请求到服务 A 时， 服务 A 会生成一个类似 UUID 的 traceId 字符串，将此字符串放入当前线程的 ThreadLocal 中，在调用服务 B 的时候，将 traceId 写入到请求的 Header 中，服务 B 在接收请求时会先判断请求的 Header 中是否有 traceId，如果存在则写入自己线程的 ThreadLocal 中。</p>
<p>img</p>
<p>图中的 requestId 即为我们各个系统链路关联的 traceId，系统间互相调用，通过这个 requestId 即可找到对应链路，这里还有会有一些其他场景：</p>
<p>img</p>
<p>针对于这些场景，我们都可以有相应的解决方案，如下所示</p>
<p>Feign 远程调用解决方案<br>服务发送请求：</p>
<pre><code class="bash">@Component
@Slf4j
public class FeignInvokeInterceptor implements RequestInterceptor {

    @Override
    public void apply(RequestTemplate template) {
        String requestId = MDC.get("requestId");
        if (StringUtils.isNotBlank(requestId)) {
            template.header("requestId", requestId);
        }
    }
}
</code></pre>
<p>服务接收请求：</p>
<pre><code class="bash">@Slf4j
@Component
public class LogInterceptor extends HandlerInterceptorAdapter {

    @Override
    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) {
        MDC.remove("requestId");
    }

    @Override
    public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) {
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        String requestId = request.getHeader(BaseConstant.REQUEST_ID_KEY);
        if (StringUtils.isBlank(requestId)) {
            requestId = UUID.randomUUID().toString().replace("-", "");
        }
        MDC.put("requestId", requestId);
        return true;
    }
}
</code></pre>
<p>线程池异步调用，requestId 传递<br>因为 MDC 是基于 ThreadLocal 去实现的，异步过程中，子线程并没有办法获取到父线程 ThreadLocal 存储的数据，所以这里可以自定义线程池执行器，修改其中的 run() 方法：</p>
<pre><code class="bash">public class MyThreadPoolTaskExecutor extends ThreadPoolTaskExecutor {

    @Override
    public void execute(Runnable runnable) {
        Map&lt;String, String&gt; context = MDC.getCopyOfContextMap();
        super.execute(() -&gt; run(runnable, context));
    }

    @Override
    private void run(Runnable runnable, Map&lt;String, String&gt; context) {
        if (context != null) {
            MDC.setContextMap(context);
        }
        try {
            runnable.run();
        } finally {
            MDC.remove();
        }
    }
}
</code></pre>
<p>使用 MQ 发送消息给第三方系统<br>在 MQ 发送的消息体中自定义属性 requestId，接收方消费消息后，自己解析 requestId 使用即可。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">阿健君</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/08/11/collection/ThreadLocal%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://example.com/2020/08/11/collection/ThreadLocal%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">HJ 的学习录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ThreadLocalMap/">ThreadLocalMap</a><a class="post-meta__tags" href="/tags/set/">set</a><a class="post-meta__tags" href="/tags/key-%E8%BF%87%E6%9C%9F%E6%B8%85%E7%90%86%E7%AD%96%E7%95%A5/">key 过期清理策略</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/6.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信扫码"></a><div class="post-qr-code-desc">微信扫码</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝扫码"></a><div class="post-qr-code-desc">支付宝扫码</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/17/io/%E7%A5%9E%E7%A7%98%E7%9A%84%20Java%20NIO/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210709111120737.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">神秘的 Java NIO</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/31/collection/ConcurrentHashMap%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/ConcurrentHashMap.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ConcurrentHashMap 源码分析</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">阿健君</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">105</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>qq:1064821280</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/junian455" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1064821280@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://junian455.github.io/" target="_blank" title="Blog"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哈喽，有问题的话请在留言板留言，我看到会第一时间回复你。</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/collection/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86/" title="红黑树原理"><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/%E7%BA%A2%E9%BB%912%E6%A0%91.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红黑树原理"></a><div class="content"><a class="title" href="/2022/04/16/collection/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86/" title="红黑树原理">红黑树原理</a><time datetime="2022-04-16T02:55:00.000Z" title="发表于 2022-04-16 10:55:00">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/02/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式-行为型设计模式"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式-行为型设计模式"></a><div class="content"><a class="title" href="/2022/04/02/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式-行为型设计模式">设计模式-行为型设计模式</a><time datetime="2022-04-02T08:11:00.000Z" title="发表于 2022-04-02 16:11:00">2022-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/14/redis/%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%BB%E9%87%8D%EF%BC%9F/" title="怎么利用Redis实现数据的去重？"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/cache.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="怎么利用Redis实现数据的去重？"></a><div class="content"><a class="title" href="/2022/03/14/redis/%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%BB%E9%87%8D%EF%BC%9F/" title="怎么利用Redis实现数据的去重？">怎么利用Redis实现数据的去重？</a><time datetime="2022-03-14T06:29:00.000Z" title="发表于 2022-03-14 14:29:00">2022-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/SEATA/" title="SEATA"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/seata.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SEATA"></a><div class="content"><a class="title" href="/2022/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/SEATA/" title="SEATA">SEATA</a><time datetime="2022-01-20T07:11:00.000Z" title="发表于 2022-01-20 15:11:00">2022-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式事务"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/traditional.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式事务"></a><div class="content"><a class="title" href="/2022/01/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式事务">分布式事务</a><time datetime="2022-01-10T03:11:00.000Z" title="发表于 2022-01-10 11:11:00">2022-01-10</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2022 By 阿健君</div><div class="footer_custom_text"><span style="margin-top:5px;display:inline-block;font-weight:bold;font-size:14px">一分耕耘，一分收获。</span><p></p> <p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架为Hexo" data-ll-status="loading" class="entered loading"></a>&nbsp;<a target="_blank" href="https://demo.jerryc.me/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题采用butterfly" data-ll-status="loading" class="entered loading"></a>&nbsp;<a target="_blank" href="https://metroui.org.ua/index.html "><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速" data-ll-status="loading" class="entered loading"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&amp;logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel" data-ll-status="loading" class="entered loading"></a>&nbsp;<a class="github-badge" target="_blank" href="https://beian.miit.gov.cn" style="margin-inline:5px" title="本站已在工信部备案，备案号浙ICP备-2022001668号"><img src="http://cdn.ymktchic.top/img/202201212329189.svg" data-lazy-src="" alt="" data-ll-status="loaded" class="entered loaded"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" data-ll-status="loading" class="entered loading"></a> <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="95" height="20" role="img" aria-label="CDN:又拍云"><title>CDN:又拍云</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"></stop><stop offset="1" stop-opacity=".1"></stop></linearGradient><clipPath id="r"><rect width="95" height="20" rx="3" fill="#fff"></rect></clipPath><g clip-path="url(#r)"><rect width="52" height="20" fill="#555"></rect><rect x="52" width="43" height="20" fill="#00b6ff"></rect><rect width="95" height="20" fill="url(#s)"></rect></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><image x="5" y="3" width="14" height="14" xlink:href="https://developer.qiniu.com/assets/logo-white-b90d685a6b146884636382426d11b7236f5f7ca1c5dfafdb6fa777a0f976fc1f.png"></image><text aria-hidden="true" x="355" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="250">CDN</text><text x="355" y="140" transform="scale(.1)" fill="#fff" textLength="250">CDN</text><text aria-hidden="true" x="725" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="330">七牛云</text><text x="725" y="140" transform="scale(.1)" fill="#fff" textLength="330">七牛云</text></g></svg></p></div></div><div class="container" id="jsi-flying-fish-container"></div><style>@media only screen and (max-width: 767px){
  #sidebar_search_box input[type=text]{width:calc(100% - 24px)}
}</style></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2020/08/11/collection/ThreadLocal%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/'
    this.page.identifier = '2020/08/11/collection/ThreadLocal 源码解析/'
    this.page.title = 'ThreadLocal 源码解析'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="/js/card_categor_hide.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script data-pjax="" src="https://cdn.jsdelivr.net/gh/Jnylife/CDN@1.3/js/fish.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/WithoutLine.min.js"></script><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>