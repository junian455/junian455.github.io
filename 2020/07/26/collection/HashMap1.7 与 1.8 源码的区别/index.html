<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HashMap1.7 与 1.8 源码的区别 | HJ 的学习录</title><meta name="keywords" content="java,HashMap"><meta name="author" content="阿健君"><meta name="copyright" content="阿健君"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="简介类定义JAVA123public class HashMap<K,V>         extends AbstractMap<K,V>         implements Map<K,V>, Cloneable, Serializable主要简介 img 数据结构：引入了 红黑树 img 存储流程 img 数组元素 &amp; 链表节点的 实现类Hash">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap1.7 与 1.8 源码的区别">
<meta property="og:url" content="http://example.com/2020/07/26/collection/HashMap1.7%20%E4%B8%8E%201.8%20%E6%BA%90%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB/index.html">
<meta property="og:site_name" content="HJ 的学习录">
<meta property="og:description" content="简介类定义JAVA123public class HashMap<K,V>         extends AbstractMap<K,V>         implements Map<K,V>, Cloneable, Serializable主要简介 img 数据结构：引入了 红黑树 img 存储流程 img 数组元素 &amp; 链表节点的 实现类Hash">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/hashmap.jpeg">
<meta property="article:published_time" content="2020-07-26T08:05:00.000Z">
<meta property="article:modified_time" content="2020-07-26T08:05:00.000Z">
<meta property="article:author" content="阿健君">
<meta property="article:tag" content="java">
<meta property="article:tag" content="HashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/hashmap.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/07/26/collection/HashMap1.7%20%E4%B8%8E%201.8%20%E6%BA%90%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HashMap1.7 与 1.8 源码的区别',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2020-07-26 16:05:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/scollbar.css"><link rel="stylesheet" href="/css/bottomsetting.css"><link rel="stylesheet" href="/css/card_categor_hide.css"><link rel="stylesheet" href="/css/article_bak_transparent.css"><link rel="stylesheet" href="/css/index_tag.css"><link rel="stylesheet" href="/css/index_tag2.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/index_tag3.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-th-large"></i><span> 百宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-user-shield"></i><span> 评论管理</span></a></li><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-cloud"></i><span> 我的云盘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-photo-video"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-child"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fa-fw fas fa-user-friends"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa-fw fas fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/hashmap.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HJ 的学习录</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-th-large"></i><span> 百宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-user-shield"></i><span> 评论管理</span></a></li><li><a class="site-page child" href="//"><i class="fa-fw fa-fw fas fa-cloud"></i><span> 我的云盘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-photo-video"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-child"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fa-fw fas fa-user-friends"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa-fw fas fa-comments"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HashMap1.7 与 1.8 源码的区别</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-26T08:05:00.000Z" title="发表于 2020-07-26 16:05:00">2020-07-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-07-26T08:05:00.000Z" title="更新于 2020-07-26 16:05:00">2020-07-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9B%86%E5%90%88/">集合</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HashMap1.7 与 1.8 源码的区别"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/hashmap.jpeg');"></div><article class="post-content" id="article-container"><p>简介<br>类定义<br>JAVA<br>1<br>2<br>3<br>public class HashMap&lt;K,V&gt;<br>         extends AbstractMap&lt;K,V&gt;<br>         implements Map&lt;K,V&gt;, Cloneable, Serializable<br>主要简介</p>
<p>img</p>
<p>数据结构：引入了 红黑树</p>
<p>img</p>
<p>存储流程</p>
<p>img</p>
<p>数组元素 &amp; 链表节点的 实现类<br>HashMap 中的数组元素 &amp; 链表节点采用 Node 类 实现。</p>
<p>与 JDK 1.7 的对比（Entry 类），仅仅只是换了名字。</p>
<p>该类的源码分析如下：</p>
<pre><code class="bash">/** 
  * Node  = HashMap的内部类，实现了Map.Entry接口，本质是 = 一个映射(键值对)
  * 实现了getKey()、getValue()、equals(Object o)和hashCode()等方法
  **/  

  static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {

        final int hash; // 哈希值，HashMap根据该值确定记录的位置
        final K key; // key
        V value; // value
        Node&lt;K,V&gt; next;// 链表下一个节点

        // 构造方法
        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
        
        public final K getKey()        { return key; }   // 返回 与 此项 对应的键
        public final V getValue()      { return value; } // 返回 与 此项 对应的值
        public final String toString() { return key + "=" + value; }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

      /** 
        * hashCode（） 
        */
        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

      /** 
        * equals（）
        * 作用：判断2个Entry是否相等，必须key和value都相等，才返回true  
        */
        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;&amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
</code></pre>
<h2 id="红黑树节点实现类"><a href="#红黑树节点实现类" class="headerlink" title="红黑树节点实现类"></a>红黑树节点实现类</h2><p>HashMap 中的红黑树节点采用 TreeNode 类 实现：</p>
<pre><code class="bash">/**
 * 红黑树节点 实现类：继承自LinkedHashMap.Entry&lt;K,V&gt;类
 */
 static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {  
  
   // 属性 = 父节点、左子树、右子树、删除辅助节点 + 颜色
   TreeNode&lt;K,V&gt; parent;  
   TreeNode&lt;K,V&gt; left;   
   TreeNode&lt;K,V&gt; right;
   TreeNode&lt;K,V&gt; prev;   
   boolean red;   
  
   // 构造函数
   TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {  
       super(hash, key, val, next);  
   }  
 
   // 返回当前节点的根节点  
   final TreeNode&lt;K,V&gt; root() {  
       for (TreeNode&lt;K,V&gt; r = this, p;;) {  
           if ((p = r.parent) == null)  
               return r;  
           r = p;  
       }  
   } 
</code></pre>
<p>具体方法使用<br>主要使用 API（方法、函数）<br>与 JDK 1.7 基本相同。</p>
<pre><code class="bash">V get(Object key); // 获得指定键的值
V put(K key, V value);  // 添加键值对
void putAll(Map&lt;? extends K, ? extends V&gt; m);  // 将指定Map中的键值对 复制到 此Map中
V remove(Object key);  // 删除该键值对

boolean containsKey(Object key); // 判断是否存在该键的键值对；是 则返回true
boolean containsValue(Object value);  // 判断是否存在该值的键值对；是 则返回true
 
Set&lt;K&gt; keySet();  // 单独抽取key序列，将所有key生成一个Set
Collection&lt;V&gt; values();  // 单独value序列，将所有value生成一个Collection

void clear(); // 清除哈希表中的所有键值对
int size();  // 返回哈希表中所有 键值对的数量 = 数组中的键值对 + 链表中的键值对
boolean isEmpty(); // 判断HashMap是否为空；size == 0时 表示为 空 
</code></pre>
<p>使用流程<br>与 JDK 1.7 基本相同</p>
<p>在具体使用时，主要流程是：</p>
<p>声明 1 个 HashMap 的对象；<br>向 HashMap 添加数据（成对 放入 键 - 值对）；<br>获取 HashMap 的某个数据；<br>获取 HashMap 的全部数据：遍历 HashMap。<br>示例代码：</p>
<pre><code class="bash">import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class HashMapTest {

    public static void main(String[] args) {
      /**
        * 1. 声明1个 HashMap的对象
        */
        Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();

      /**
        * 2. 向HashMap添加数据（成对 放入 键 - 值对）
        */
        map.put("Android", 1);
        map.put("Java", 2);
        map.put("iOS", 3);
        map.put("数据挖掘", 4);
        map.put("产品经理", 5);

       /**
        * 3. 获取 HashMap 的某个数据
        */
        System.out.println("key = 产品经理时的值为：" + map.get("产品经理"));

      /**
        * 4. 获取 HashMap 的全部数据：遍历HashMap
        * 核心思想：
        * 步骤1：获得key-value对（Entry） 或 key 或 value的Set集合
        * 步骤2：遍历上述Set集合(使用for循环 、 迭代器（Iterator）均可)
        * 方法共有3种：分别针对 key-value对（Entry） 或 key 或 value
        */

        // 方法1：获得key-value的Set集合 再遍历
        System.out.println("方法1");
        // 1. 获得key-value对（Entry）的Set集合
        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();

        // 2. 遍历Set集合，从而获取key-value
        // 2.1 通过for循环
        for(Map.Entry&lt;String, Integer&gt; entry : entrySet){
            System.out.print(entry.getKey());
            System.out.println(entry.getValue());
        }
        System.out.println("----------");
        // 2.2 通过迭代器：先获得key-value对（Entry）的Iterator，再循环遍历
        Iterator iter1 = entrySet.iterator();
        while (iter1.hasNext()) {
            // 遍历时，需先获取entry，再分别获取key、value
            Map.Entry entry = (Map.Entry) iter1.next();
            System.out.print((String) entry.getKey());
            System.out.println((Integer) entry.getValue());
        }


        // 方法2：获得key的Set集合 再遍历
        System.out.println("方法2");

        // 1. 获得key的Set集合
        Set&lt;String&gt; keySet = map.keySet();

        // 2. 遍历Set集合，从而获取key，再获取value
        // 2.1 通过for循环
        for(String key : keySet){
            System.out.print(key);
            System.out.println(map.get(key));
        }

        System.out.println("----------");

        // 2.2 通过迭代器：先获得key的Iterator，再循环遍历
        Iterator iter2 = keySet.iterator();
        String key = null;
        while (iter2.hasNext()) {
            key = (String)iter2.next();
            System.out.print(key);
            System.out.println(map.get(key));
        }


        // 方法3：获得value的Set集合 再遍历
        System.out.println("方法3");

        // 1. 获得value的Set集合
        Collection valueSet = map.values();

        // 2. 遍历Set集合，从而获取value
        // 2.1 获得values 的Iterator
        Iterator iter3 = valueSet.iterator();
        // 2.2 通过遍历，直接获取value
        while (iter3.hasNext()) {
            System.out.println(iter3.next());
        }

    }


}
</code></pre>
<p>// 注：对于遍历方式，推荐使用针对 key-value对（Entry）的方式：效率高<br>// 原因：<br>   // 1. 对于 遍历keySet 、valueSet，实质上 = 遍历了2次：1 = 转为 iterator 迭代器遍历、2 = 从 HashMap 中取出 key 的 value 操作（通过 key 值 hashCode 和 equals 索引）<br>   // 2. 对于 遍历 entrySet ，实质 = 遍历了1次 = 获取存储实体Entry（存储了key 和 value ）<br>运行结果：</p>
<pre><code class="bash">方法1
Java2
iOS3
数据挖掘4
Android1
产品经理5
----------
Java2
iOS3
数据挖掘4
Android1
产品经理5
方法2
Java2
iOS3
数据挖掘4
Android1
产品经理5
----------
Java2
iOS3
数据挖掘4
Android1
产品经理5
方法3
2
3
4
1
5
</code></pre>
<p>HashMap 中的重要参数（变量）</p>
<pre><code class="bash">/** 
  * 主要参数 同  JDK 1.7 
  * 即：容量、加载因子、扩容阈值（要求、范围均相同）
  */

 // 1. 容量（capacity）： 必须是2的幂 &amp; &lt;最大容量（2的30次方）
 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 默认容量 = 16 = 1&lt;&lt;4 = 00001中的1向左移4位 = 10000 = 十进制的2^4=16
 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 最大容量 =  2的30次方（若传入的容量过大，将被最大值替换）

 // 2. 加载因子(Load factor)：HashMap在其容量自动增加前可达到多满的一种尺度 
 final float loadFactor; // 实际加载因子
 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认加载因子 = 0.75

 // 3. 扩容阈值（threshold）：当哈希表的大小 ≥ 扩容阈值时，就会扩容哈希表（即扩充HashMap的容量） 
 // a. 扩容 = 对哈希表进行resize操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数
 // b. 扩容阈值 = 容量 x 加载因子
 int threshold;

 // 4. 其他
 transient Node&lt;K,V&gt;[] table;  // 存储数据的Node类型 数组，长度 = 2的幂；数组的每个元素 = 1个单链表
 transient int size;// HashMap的大小，即 HashMap中存储的键值对的数量
</code></pre>
<p> /** </p>
<ul>
<li>与红黑树相关的参数</li>
<li>/<br>// 1. 桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 &gt; 该值时，则将链表转换成红黑树<br>static final int TREEIFY_THRESHOLD = 8;<br>// 2. 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 &lt; 6时，则将 红黑树转换成链表<br>static final int UNTREEIFY_THRESHOLD = 6;<br>// 3. 最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表 （即 将链表 转换成红黑树）<br>// 否则，若桶内元素太多时，则直接扩容，而不是树形化<br>// 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD<br>static final int MIN_TREEIFY_CAPACITY = 64;<br>加载因子<br>同 JDK 1.7，但由于其重要性，故此处再次说明。</li>
</ul>
<p>img</p>
<p>总结 数据结构 &amp; 参数方面与 JDK 1.7 的区别：</p>
<p>img</p>
<p>源码分析<br>本次的源码分析主要是根据 使用步骤 进行相关函数的详细分析，主要分析内容如下：</p>
<p>img</p>
<p>源码中数据结构 &amp; 主要参数</p>
<p>img</p>
<p>步骤 1：声明 1 个 HashMap 的对象<br>此处主要分析的构造函数类似 JDK 1.7。</p>
<p>源码分析：</p>
<pre><code class="bash">/**
  * 函数使用原型
  */
  Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();

 /**
   * 源码分析：主要是HashMap的构造函数 = 4个
   * 仅贴出关于HashMap构造函数的源码
   */

public class HashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable{

    // 省略上节阐述的参数
    
  /**
     * 构造函数1：默认构造函数（无参）
     * 加载因子 &amp; 容量 = 默认 = 0.75、16
     */
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
    }

    /**
     * 构造函数2：指定“容量大小”的构造函数
     * 加载因子 = 默认 = 0.75 、容量 = 指定大小
     */
    public HashMap(int initialCapacity) {
        // 实际上是调用指定“容量大小”和“加载因子”的构造函数
        // 只是在传入的加载因子参数 = 默认加载因子
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
        
    }

    /**
     * 构造函数3：指定“容量大小”和“加载因子”的构造函数
     * 加载因子 &amp; 容量 = 自己指定
     */
    public HashMap(int initialCapacity, float loadFactor) {

        // 指定初始容量必须非负，否则报错  
         if (initialCapacity &lt; 0)  
           throw new IllegalArgumentException("Illegal initial capacity: " +  
                                           initialCapacity); 

        // HashMap的最大容量只能是MAXIMUM_CAPACITY，哪怕传入的 &gt; 最大容量
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;

        // 填充比必须为正  
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))  
            throw new IllegalArgumentException("Illegal load factor: " +  
                                           loadFactor);  
        // 设置 加载因子
        this.loadFactor = loadFactor;

        // 设置 扩容阈值
        // 注：此处不是真正的阈值，仅仅只是将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂，该阈值后面会重新计算
        // 下面会详细讲解 -&gt;&gt; 分析1
        this.threshold = tableSizeFor(initialCapacity); 

    }

    /**
     * 构造函数4：包含“子Map”的构造函数
     * 即 构造出来的HashMap包含传入Map的映射关系
     * 加载因子 &amp; 容量 = 默认
     */

    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {

        // 设置容量大小 &amp; 加载因子 = 默认
        this.loadFactor = DEFAULT_LOAD_FACTOR; 

        // 将传入的子Map中的全部元素逐个添加到HashMap中
        putMapEntries(m, false); 
    }
}

   /**
     * 分析1：tableSizeFor(initialCapacity)
     * 作用：将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂
     * 与JDK 1.7对比：类似于JDK 1.7 中 inflateTable()里的 roundUpToPowerOf2(toSize)
     */
    static final int tableSizeFor(int cap) {
     int n = cap - 1;
     n |= n &gt;&gt;&gt; 1;
     n |= n &gt;&gt;&gt; 2;
     n |= n &gt;&gt;&gt; 4;
     n |= n &gt;&gt;&gt; 8;
     n |= n &gt;&gt;&gt; 16;
     return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
注：（同 JDK 1.7 类似）
</code></pre>
<p>此处仅用于接收初始容量大小（capacity）、加载因子 (Load factor)，但仍无真正初始化哈希表，即初始化存储数组 table。<br>此处先给出结论：真正初始化哈希表（初始化存储数组 table）是在第 1 次添加键值对时，即第 1 次调用 put（）时。下面会详细说明。<br>步骤 2：向 HashMap 添加数据（成对 放入 键 - 值对）<br>在该步骤中，与 JDK 1.7 的差别较大：</p>
<p>img</p>
<p>添加数据的流程如下：</p>
<p>img</p>
<p>源码分析</p>
<pre><code class="bash">/**
  * 函数使用原型
  */
  map.put("Android", 1);
       map.put("Java", 2);
       map.put("iOS", 3);
       map.put("数据挖掘", 4);
       map.put("产品经理", 5);

  /**
    * 源码分析：主要分析HashMap的put函数
    */
   public V put(K key, V value) {
       // 1. 对传入数组的键Key计算Hash值 -&gt;&gt;分析1
       // 2. 再调用putVal（）添加数据进去 -&gt;&gt;分析2
       return putVal(hash(key), key, value, false, true);
   }
</code></pre>
<p>分析 1：hash（key）</p>
<pre><code class="bash">/**
  * 分析1：hash(key)
  * 作用：计算传入数据的哈希码（哈希值、Hash值）
  * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）
  * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算
  * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算
  */

   // JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）
   static final int hash(int h) {
     h ^= k.hashCode(); 
     h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
     return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
  }

   // JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）
   // 1. 取hashCode值： h = key.hashCode() 
   // 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  
   static final int hash(Object key) {
        int h;
         return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
         // a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      
         // 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null
         // b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行 扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制
  }

/**
  * 计算存储位置的函数分析：indexFor(hash, table.length)
  * 注：该函数仅存在于JDK 1.7 ，JDK 1.8中实际上无该函数（直接用1条语句判断写出），但原理相同
  * 为了方便讲解，故提前到此讲解
  */
  static int indexFor(int h, int length) {  
       return h &amp; (length-1); 
       // 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）
       }
</code></pre>
<p>计算存放在数组 table 中的位置（即数组下标、索引）的过程：</p>
<p>此处与 JDK 1.7 的区别在于：hash 值的求解过程中哈希码的二次处理方式（扰动处理）。<br>步骤 1、2 = hash 值的求解过程。</p>
<p>img</p>
<p>计算示意图：</p>
<p>img</p>
<p>在了解如何计算存放数组 table 中的位置 后，所谓 知其然而需知其所以然，下面讲解为什么要这样计算，即主要解答以下 3 个问题：</p>
<p>为什么不直接采用经过 hashCode（）处理的哈希码作为存储数组 table 的下标位置？<br>为什么采用 哈希码 与运算 (&amp;) （数组长度 - 1） 计算数组下标？<br>为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？<br>在回答这 3 个问题前，请大家记住一个核心思想：所有处理的根本目的，都是为了提高存储 key-value 的数组下标位置的随机性 &amp; 分布均匀性，尽量避免出现 hash 值冲突。即：对于不同 key，存储的数组下标位置要尽可能不一样。</p>
<p>为什么不直接采用经过 hashCode（）处理的哈希码作为存储数组 table 的下标位置？</p>
<p>结论：容易出现哈希码与数组大小范围不匹配的情况，即计算出来的哈希码可能不在数组大小范围内，从而导致无法匹配存储位置。</p>
<p>img</p>
<p>为了解决 “哈希码与数组大小范围不匹配” 的问题，HashMap 给出了解决方案：哈希码与运算（&amp;） （数组长度 - 1），即问题 3。</p>
<p>为什么采用哈希码与运算 (&amp;) （数组长度 - 1） 计算数组下标？</p>
<p>结论：根据 HashMap 的容量大小（数组长度），按需取哈希码一定数量的低位作为存储的数组下标位置，从而 解决 “哈希码与数组大小范围不匹配” 的问题。</p>
<p>img</p>
<p>为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？</p>
<p>结论：加大哈希码低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性 &amp; 均匀性，最终减少 Hash 冲突。</p>
<p>img</p>
<p>分析 2：putVal (hash (key), key, value, false, true)<br>计算完存储位置后，具体该如何存放数据到哈希表中。<br>具体如何扩容，即 扩容机制。<br>由于数据结构中加入了红黑树，所以在存放数据到哈希表中时，需进行多次数据结构的判断：数组、红黑树、链表。</p>
<p>与 JDK 1.7 的区别： JDK 1.7 只需判断 数组 &amp; 链表。</p>
<p>img</p>
<p>源码分析：</p>
<pre><code class="bash">   /**
     * 分析2：putVal(hash(key), key, value, false, true)
     */

    //onlyIfAbsent：插入的值是否存在，存在就不插了。
     final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {

            Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;

        // 1. 若哈希表的数组tab为空，则 通过resize() 创建
        // 所以，初始化哈希表的时机 = 第1次调用put函数时，即调用resize() 初始化创建
        // 关于resize（）的源码分析将在下面讲解扩容时详细分析，此处先跳过
        if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;

        // 2. 计算插入存储的数组索引i：根据键值key计算的hash值 得到
        // 此处的数组下标计算方式 = i = (n - 1) &amp; hash，同JDK 1.7中的indexFor（），上面已详细描述

        // 3. 插入时，需判断是否存在Hash冲突：
        // 若不存在（即当前table[i] == null），则直接在该数组位置新建节点，插入完毕
        // 否则，代表存在Hash冲突，即当前存储位置已存在节点，则依次往下判断：a. 当前位置的key是否与需插入的key相同、b. 判断需插入的数据结构是否为红黑树 or 链表
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);  // newNode(hash, key, value, null)的源码 = new Node&lt;&gt;(hash, key, value, next)

    else {
        Node&lt;K,V&gt; e; K k;

        // a. 判断 table[i]的元素的key是否与 需插入的key一样，若相同则 直接用新value 覆盖 旧value
        // 判断原则：equals（）
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;

        // b. 继续判断：需插入的数据结构是否为红黑树 or 链表
        // 若是红黑树，则直接在树中插入 or 更新键值对
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); -&gt;&gt;分析3

        // 若是链表,则在链表中插入 or 更新键值对
        // i.  遍历table[i]，判断Key是否已存在：采用equals（） 对比当前遍历节点的key 与 需插入数据的key：若已存在，则直接用新value 覆盖 旧value
        // ii. 遍历完毕后仍无发现上述情况，则直接在链表尾部插入数据
        // 注：新增节点后，需判断链表长度是否&gt;8（8 = 桶的树化阈值）：若是，则把链表转换为红黑树
        
        else {
            for (int binCount = 0; ; ++binCount) {
                // 对于ii：若数组的下1个位置，表示已到表尾也没有找到key值相同节点，则新建节点 = 插入节点
                // 注：此处是从链表尾插入，与JDK 1.7不同（从链表头插入，即永远都是添加到数组的位置，原来数组位置的数据则往后移）
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);

                    // 插入节点后，若链表节点&gt;树阈值，则将链表转换为红黑树
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) 
                        treeifyBin(tab, hash); // 树化操作
                    break;
                }

                // 对于i
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;

                // 更新p指向下一个节点，继续遍历
                p = e;
            }
        }

        // 对i情况的后续操作：发现key已存在，直接用新value 覆盖 旧value &amp; 返回旧value
        if (e != null) { 
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e); // 替换旧值时会调用的方法（默认实现为空）
            return oldValue;
        }
    }

    ++modCount; //表示散列表结构被修改的次数，替换Node元素的value不计数

    // 插入成功后，判断实际存在的键值对数量size &gt; 最大容量threshold
    // 若 &gt; ，则进行扩容 -&gt;&gt;分析4（但单独讲解，请直接跳出该代码块）
    if (++size &gt; threshold)
        resize();

    afterNodeInsertion(evict);// 插入成功时会调用的方法（默认实现为空）
    return null;

}

    /**
     * 分析3：putTreeVal(this, tab, hash, key, value)
     * 作用：向红黑树插入 or 更新数据（键值对）
     * 过程：遍历红黑树判断该节点的key是否与需插入的key 相同：
     *      a. 若相同，则新value覆盖旧value
     *      b. 若不相同，则插入
     */

     final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,
                                       int h, K k, V v) {
            Class&lt;?&gt; kc = null;
            boolean searched = false;
            TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;
            for (TreeNode&lt;K,V&gt; p = root;;) {
                int dir, ph; K pk;
                if ((ph = p.hash) &gt; h)
                    dir = -1;
                else if (ph &lt; h)
                    dir = 1;
                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))
                    return p;
                else if ((kc == null &amp;&amp;
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0) {
                    if (!searched) {
                        TreeNode&lt;K,V&gt; q, ch;
                        searched = true;
                        if (((ch = p.left) != null &amp;&amp;
                             (q = ch.find(h, k, kc)) != null) ||
                            ((ch = p.right) != null &amp;&amp;
                             (q = ch.find(h, k, kc)) != null))
                            return q;
                    }
                    dir = tieBreakOrder(k, pk);
                }

                TreeNode&lt;K,V&gt; xp = p;
                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {
                    Node&lt;K,V&gt; xpn = xp.next;
                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);
                    if (dir &lt;= 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    xp.next = x;
                    x.parent = x.prev = xp;
                    if (xpn != null)
                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;
                    moveRootToFront(tab, balanceInsertion(root, x));
                    return null;
                }
            }
        }
</code></pre>
<p>put 流程：</p>
<p>img</p>
<p>扩容机制（即 resize（）函数方法）<br>扩容流程如下：</p>
<p>img</p>
<p>源码分析：</p>
<pre><code class="bash">   //为什么需要扩容？ 元素太多就会导致查询效率由O(1)-&gt;O(n) 扩容后使得元素更加分散，查询效率更高
   //为了解决哈希冲突导致的链化影响查询效率的问题，扩容会缓解该问题
    /**
     * 分析4：resize（）
     * 该函数有2种使用情况：1.初始化哈希表 2.当前数组容量过小，需扩容
     */
   final Node&lt;K,V&gt;[] resize() {
    Node&lt;K,V&gt;[] oldTab = table; // 扩容前的数组（当前数组）
    int oldCap = (oldTab == null) ? 0 : oldTab.length; // 扩容前的数组的容量 = 长度
    int oldThr = threshold;// 扩容前的数组的阈值
    int newCap, newThr = 0;

    // 针对情况2：若扩容前的数组容量超过最大值，则不再扩充
    if (oldCap &gt; 0) {
        if (oldCap &gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }

        // 针对情况2：若无超过最大值，就扩充为原来的2倍
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // 通过右移扩充2倍
    }

    // 针对情况1：初始化哈希表（采用指定 or 默认值）
    /*oldCap == 0 ，说明hashMap中的散列表是null
    *    1. new HashMap(initCap,loadFactor);
    *   2. new HashMap(intiCap);
    *   3. new HashMap(map);并且这个map有数据     
    */
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;

    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }

    // 计算新的resize上限
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }

    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;

    if (oldTab != null) {
        // 把每个bucket都移动到新的buckets中
        for (int j = 0; j &lt; oldCap; ++j) {
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;

                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                //第三种情况：桶位已经形成链表
                        
                //低位链表：存放扩容之前的数组下标位置，与当期位置的下标位置一致
                //高位链表：存放扩容之后的数组下标位置为 当前数组下标位置 + 扩容之后数组的长度
                else { // 链表优化重hash的代码块
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do {
                        next = e.next;
                        // 原索引
                        if ((e.hash &amp; oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // 原索引 + oldCap
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // 原索引放到bucket里
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // 原索引+oldCap放到bucket里
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
</code></pre>
<p>扩容流程（含 与 JDK 1.7 的对比）：</p>
<p>img</p>
<p>这里主要是 JDK 1.8 扩容时，数据存储位置重新计算的方式。</p>
<p>image-20210708221831834</p>
<p>结论示意图：</p>
<p>img</p>
<p>数组位置转换的示意图：</p>
<p>image-20210708214220642</p>
<p>JDK 1.8 根据此结论作出的新元素存储位置计算规则非常简单，提高了扩容效率，具体如下图。</p>
<p>这与 JDK 1.7 在计算新元素的存储位置有很大区别：JDK 1.7 在扩容后，都需按照原来方法重新计算，即<br>hashCode（）-&gt;&gt; 扰动处理 -&gt;&gt;（h &amp; length-1））。</p>
<p>与 JDK 1.7 的区别：</p>
<p>img</p>
<p>步骤 3：从 HashMap 中获取数据<br>假如理解了上述 put（）函数的原理，那么 get（）函数非常好理解，因为二者的过程原理几乎相同。</p>
<p>get（）函数的流程如下：</p>
<p>img</p>
<p>源码分析：</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>/**</p>
<ul>
<li>函数原型</li>
<li>作用：根据键key，向HashMap获取对应的值</li>
<li>/<br>map.get(key)；</li>
</ul>
<p> /**</p>
<ul>
<li>源码分析</li>
<li>/<br>public V get(Object key) {<br>Node&lt;K,V&gt; e;<br>// 1. 计算需获取数据的hash值<br>// 2. 通过getNode（）获取所查询的数据 -&gt;&gt;分析1<br>// 3. 获取后，判断数据是否为空<br>return (e = getNode(hash(key), key)) == null ? null : e.value;<br>}</li>
</ul>
<p>/**</p>
<ul>
<li><p>分析1：getNode(hash(key), key))</p>
</li>
<li><p>/<br>final Node&lt;K,V&gt; getNode(int hash, Object key) {<br>Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</p>
<p>// 1. 计算存放在数组table中的位置<br>if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</p>
<pre><code>(first = tab[(n - 1) &amp; hash]) != null) {

// 4. 通过该函数，依次在数组、红黑树、链表中查找（通过equals（）判断）
// a. 先在数组中找，若存在，则直接返回
if (first.hash == hash &amp;&amp; // always check first node
    ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
    return first;

// b. 若数组中没有，则到红黑树中寻找
if ((e = first.next) != null) {
    // 在树中get
    if (first instanceof TreeNode)
        return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);

    // c. 若红黑树中也没有，则通过遍历，到链表中寻找
    do {
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
            return e;
    } while ((e = e.next) != null);
}
</code></pre>
<p>}<br>return null;<br>}<br>步骤 4：对 HashMap 的其他操作<br>HashMap 除了核心的 put（）、get（）函数，还有以下主要使用的函数方法：</p>
</li>
</ul>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>void clear(); // 清除哈希表中的所有键值对<br>int size();  // 返回哈希表中所有 键值对的数量 = 数组中的键值对 + 链表中的键值对<br>boolean isEmpty(); // 判断HashMap是否为空；size == 0时 表示为 空 </p>
<p>void putAll(Map&lt;? extends K, ? extends V&gt; m);  // 将指定Map中的键值对 复制到 此Map中<br>V remove(Object key);  // 删除该键值对</p>
<p>boolean containsKey(Object key); // 判断是否存在该键的键值对；是 则返回true<br>boolean containsValue(Object value);  // 判断是否存在该值的键值对；是 则返回true<br>关于上述方法的源码的原理 同 JDK 1.7，此处不作过多描述。<br>总结内容 = 数据结构、主要参数、添加 &amp; 查询数据流程、扩容机制.<br>removeNode()<br>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,<br>                               boolean matchValue, boolean movable) {<br>        //tab：引用当前hashMap的散列表<br>        //p：当前node元素（桶位中头元素）<br>        //n：表示散列表数组长度<br>        //index:表示寻址结果<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</p>
<pre><code>    //说明路由的桶位是有数据的，需要进行查找操作，并且删除
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (p = tab[index = (n - 1) &amp; hash]) != null) {
            
        //node：查找到的结果
        //e：当前Node的下一个元素
        Node&lt;K,V&gt; node = null, e; K k; V v;
        
        //第一种情况：当前桶位中的元素 即为要删除的元素
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            node = p;
            
        
        else if ((e = p.next) != null) {
            //说明当前桶位不止一个元素，可能是链表，可能是红黑树
            
            if (p instanceof TreeNode) 判断当前桶位是否升级为红黑树
                //第二种情况：红黑树查找操作
                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
                
            else {
                //第三种情况：链表
                do {
                    //循环链表 查找node节点
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key ||
                         (key != null &amp;&amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;  //保证e一直往下查找
                } while ((e = e.next) != null);一直向下找
            }
        }
        
        //删除数据
        //判断node不为空的话，说明按照key查找到需要删除的数据了
        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                             (value != null &amp;&amp; value.equals(v)))) {
            
            //第一种情况：node是树节点，说明需要进行树节点移除操作                
            if (node instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
            
            //第二种情况：桶位元素即为查找结果，则将该元素的下一个元素放到桶位中
            else if (node == p)
                tab[index] = node.next;
                
                //第三种情况：将当前元素p的下一个元素 设置成 要删除的下一个元素
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
</code></pre>
<p>clear()<br>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>依次将数组中的元素重置为null<br>    public void clear() {<br>        Node&lt;K,V&gt;[] tab;<br>        modCount++;<br>        if ((tab = table) != null &amp;&amp; size &gt; 0) {<br>            size = 0;<br>            for (int i = 0; i &lt; tab.length; ++i)<br>                tab[i] = null;<br>        }<br>    }<br>额外补充：关于 HashMap 的其他问题</p>
<p>image-20210708221739910<br>哈希表如何解决 Hash 冲突？</p>
<p>image-20210708221806238</p>
<p>为什么 HashMap 具备下述特点：键 - 值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化？</p>
<p>img</p>
<p>HashMap 线程不安全的其中一个重要原因：多线程下容易出现 resize（）死循环。 本质 = 并发 执行 put（）操作导致触发 扩容行为，从而导致 环形链表，使得在获取数据遍历链表时形成死循环，即 Infinite Loop</p>
<p>先看扩容的源码分析 resize（）：</p>
<p>JAVA<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>/**</p>
<ul>
<li><p>源码分析：resize(2 * table.length)</p>
</li>
<li><p>作用：当容量不足时（容量 &gt; 阈值），则扩容（扩到2倍）</p>
</li>
<li><p>/<br>void resize(int newCapacity) {  </p>
<p>// 1. 保存旧数组（old table）<br>Entry[] oldTable = table;  </p>
<p>// 2. 保存旧容量（old capacity ），即数组长度<br>int oldCapacity = oldTable.length; </p>
<p>// 3. 若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出<br>if (oldCapacity == MAXIMUM_CAPACITY) {  </p>
<pre><code>threshold = Integer.MAX_VALUE;  
return;  
</code></pre>
<p>}  </p>
<p>// 4. 根据新容量（2倍容量）新建1个数组，即新table<br>Entry[] newTable = new Entry[newCapacity];  </p>
<p>// 5. （重点分析）将旧数组上的数据（键值对）转移到新table中，从而完成扩容 -&gt;&gt;分析1.1<br>transfer(newTable); </p>
<p>// 6. 新数组table引用到HashMap的table属性上<br>table = newTable;  </p>
<p>// 7. 重新设置阈值<br>threshold = (int)(newCapacity * loadFactor);<br>} </p>
</li>
</ul>
<p> /**</p>
<ul>
<li><p>分析1.1：transfer(newTable); </p>
</li>
<li><p>作用：将旧数组上的数据（键值对）转移到新table中，从而完成扩容</p>
</li>
<li><p>过程：按旧链表的正序遍历链表、在新链表的头部依次插入</p>
</li>
<li><p>/<br>void transfer(Entry[] newTable) {<br>  // 1. src引用了旧数组<br>  Entry[] src = table; </p>
<p>  // 2. 获取新数组的大小 = 获取新容量大小<br>  int newCapacity = newTable.length;</p>
<p>  // 3. 通过遍历 旧数组，将旧数组上的数据（键值对）转移到新数组中<br>  for (int j = 0; j &lt; src.length; j++) { </p>
<pre><code>  // 3.1 取得旧数组的每个元素  
  Entry&lt;K,V&gt; e = src[j];           
  if (e != null) {
      // 3.2 释放旧数组的对象引用（for循环后，旧数组不再引用任何对象）
      src[j] = null; 

      do { 
          // 3.3 遍历 以该数组元素为首 的链表
          // 注：转移链表时，因是单链表，故要保存下1个结点，否则转移后链表会断开
          Entry&lt;K,V&gt; next = e.next; 
         // 3.3 重新计算每个元素的存储位置
         int i = indexFor(e.hash, newCapacity); 
         // 3.4 将元素放在数组上：采用单链表的头插入方式 = 在链表头上存放数据 = 将数组位置的原有数据放在后1个指针、将需放入的数据放到数组位置中
         // 即 扩容后，可能出现逆序：按旧链表的正序遍历链表、在新链表的头部依次插入
         e.next = newTable[i]; 
         newTable[i] = e;  
         // 访问下1个Entry链上的元素，如此不断循环，直到遍历完该链表上的所有节点
         e = next;             
     } while (e != null);
     // 如此不断循环，直到遍历完数组上的所有数据元素
 }
</code></pre>
<p> }<br>}<br>从上面可看出：在扩容 resize（）过程中，在将旧数组上的数据 转移到 新数组上时，转移数据操作 = 按旧链表的正序遍历链表、在新链表的头部依次插入，即在转移数据、扩容后，容易出现链表逆序的情况。</p>
</li>
</ul>
<p>设重新计算存储位置后不变，即扩容前 = 1-&gt;2-&gt;3，扩容后 = 3-&gt;2-&gt;1</p>
<p>此时若（多线程）并发执行 put（）操作，一旦出现扩容情况，则 容易出现 环形链表，从而在获取数据、遍历链表时 形成死循环（Infinite Loop），即 死锁的状态，具体请看下图：</p>
<p>img</p>
<p>img</p>
<p>image-20210708221933718</p>
<p>image-20210708222003422</p>
<p>image-20210708222037780</p>
<p>由于 JDK 1.8 转移数据操作 = 按旧链表的正序遍历链表、在新链表的尾部依次插入，所以不会出现链表 逆序、倒置的情况，故不容易出现环形链表的情况。</p>
<p>为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键？</p>
<p>img</p>
<p>HashMap 中的 key 若 Object 类型， 则需实现哪些方法？</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">阿健君</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/07/26/collection/HashMap1.7%20%E4%B8%8E%201.8%20%E6%BA%90%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB/">http://example.com/2020/07/26/collection/HashMap1.7%20%E4%B8%8E%201.8%20%E6%BA%90%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">HJ 的学习录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/HashMap/">HashMap</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/hashmap.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信扫码"></a><div class="post-qr-code-desc">微信扫码</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝扫码"></a><div class="post-qr-code-desc">支付宝扫码</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/31/collection/ConcurrentHashMap%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/ConcurrentHashMap.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ConcurrentHashMap 源码分析</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/20/collection/LinkedList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/LinkedList.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LinkedList 源码分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/10/collection/Java%20%E9%9B%86%E5%90%88/" title="Java 集合"><img class="cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/java2.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-10</div><div class="title">Java 集合</div></div></a></div><div><a href="/2020/07/20/collection/LinkedList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="LinkedList 源码分析"><img class="cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/LinkedList.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-20</div><div class="title">LinkedList 源码分析</div></div></a></div><div><a href="/2020/07/15/collection/ArrayList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="ArrayList 源码分析"><img class="cover" src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/collection.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-15</div><div class="title">ArrayList 源码分析</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">阿健君</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>qq:1064821280</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/junian455" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1064821280@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://junian455.github.io/" target="_blank" title="Blog"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哈喽，有问题的话请在留言板留言，我看到会第一时间回复你。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">红黑树节点实现类</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/collection/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86/" title="红黑树原理"><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/%E7%BA%A2%E9%BB%912%E6%A0%91.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红黑树原理"></a><div class="content"><a class="title" href="/2022/04/16/collection/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86/" title="红黑树原理">红黑树原理</a><time datetime="2022-04-16T02:55:00.000Z" title="发表于 2022-04-16 10:55:00">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/02/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式-行为型设计模式"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式-行为型设计模式"></a><div class="content"><a class="title" href="/2022/04/02/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式-行为型设计模式">设计模式-行为型设计模式</a><time datetime="2022-04-02T08:11:00.000Z" title="发表于 2022-04-02 16:11:00">2022-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/14/redis/%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%BB%E9%87%8D%EF%BC%9F/" title="怎么利用Redis实现数据的去重？"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/cache.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="怎么利用Redis实现数据的去重？"></a><div class="content"><a class="title" href="/2022/03/14/redis/%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%BB%E9%87%8D%EF%BC%9F/" title="怎么利用Redis实现数据的去重？">怎么利用Redis实现数据的去重？</a><time datetime="2022-03-14T06:29:00.000Z" title="发表于 2022-03-14 14:29:00">2022-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/sql/select%EF%BC%8A%E5%92%8C%20select%20%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" title="select＊和 select 全部字段，它们的区别是什么？"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/es1.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="select＊和 select 全部字段，它们的区别是什么？"></a><div class="content"><a class="title" href="/2022/03/01/sql/select%EF%BC%8A%E5%92%8C%20select%20%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" title="select＊和 select 全部字段，它们的区别是什么？">select＊和 select 全部字段，它们的区别是什么？</a><time datetime="2022-03-01T02:55:00.000Z" title="发表于 2022-03-01 10:55:00">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/SEATA/" title="SEATA"><img src="https://cdn.jsdelivr.net/gh/junian455/pic@master/img/seata.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SEATA"></a><div class="content"><a class="title" href="/2022/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/SEATA/" title="SEATA">SEATA</a><time datetime="2022-01-20T07:11:00.000Z" title="发表于 2022-01-20 15:11:00">2022-01-20</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2022 By 阿健君</div><div class="footer_custom_text"><span style="margin-top:5px;display:inline-block;font-weight:bold;font-size:14px">一分耕耘，一分收获。</span><p></p> <p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架为Hexo" data-ll-status="loading" class="entered loading"></a>&nbsp;<a target="_blank" href="https://demo.jerryc.me/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题采用butterfly" data-ll-status="loading" class="entered loading"></a>&nbsp;<a target="_blank" href="https://metroui.org.ua/index.html "><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速" data-ll-status="loading" class="entered loading"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&amp;logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel" data-ll-status="loading" class="entered loading"></a>&nbsp;<a class="github-badge" target="_blank" href="https://beian.miit.gov.cn" style="margin-inline:5px" title="本站已在工信部备案，备案号浙ICP备-2022001668号"><img src="http://cdn.ymktchic.top/img/202201212329189.svg" data-lazy-src="" alt="" data-ll-status="loaded" class="entered loaded"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" data-ll-status="loading" class="entered loading"></a> <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="95" height="20" role="img" aria-label="CDN:又拍云"><title>CDN:又拍云</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"></stop><stop offset="1" stop-opacity=".1"></stop></linearGradient><clipPath id="r"><rect width="95" height="20" rx="3" fill="#fff"></rect></clipPath><g clip-path="url(#r)"><rect width="52" height="20" fill="#555"></rect><rect x="52" width="43" height="20" fill="#00b6ff"></rect><rect width="95" height="20" fill="url(#s)"></rect></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><image x="5" y="3" width="14" height="14" xlink:href="https://developer.qiniu.com/assets/logo-white-b90d685a6b146884636382426d11b7236f5f7ca1c5dfafdb6fa777a0f976fc1f.png"></image><text aria-hidden="true" x="355" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="250">CDN</text><text x="355" y="140" transform="scale(.1)" fill="#fff" textLength="250">CDN</text><text aria-hidden="true" x="725" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="330">七牛云</text><text x="725" y="140" transform="scale(.1)" fill="#fff" textLength="330">七牛云</text></g></svg></p></div></div><div class="container" id="jsi-flying-fish-container"></div><style>@media only screen and (max-width: 767px){
  #sidebar_search_box input[type=text]{width:calc(100% - 24px)}
}</style></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2020/07/26/collection/HashMap1.7%20%E4%B8%8E%201.8%20%E6%BA%90%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB/'
    this.page.identifier = '2020/07/26/collection/HashMap1.7 与 1.8 源码的区别/'
    this.page.title = 'HashMap1.7 与 1.8 源码的区别'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="/js/card_categor_hide.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script data-pjax="" src="https://cdn.jsdelivr.net/gh/Jnylife/CDN@1.3/js/fish.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/WithoutLine.min.js"></script><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>